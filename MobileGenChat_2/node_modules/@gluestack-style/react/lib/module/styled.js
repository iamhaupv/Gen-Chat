function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
/* eslint-disable react-hooks/exhaustive-deps */
import React, { useContext, useEffect, useMemo, useRef, useState } from 'react';
import { deepMerge, getResolvedTokenValueFromConfig, deepMergeObjects, resolveStringToken, shallowMerge, deepMergeArray, addThemeConditionInMeta } from './utils';
import { convertUtilityPropsToSX } from './core/convert-utility-to-sx';
import { useStyled } from './StyledProvider';
import { useTheme } from './Theme';
import { propertyTokenMap } from './propertyTokenMap';
import { Platform, StyleSheet } from 'react-native';
import { INTERNAL_updateCSSStyleInOrderedResolved } from './updateCSSStyleInOrderedResolved';
import { generateStylePropsFromCSSIds } from './generateStylePropsFromCSSIds';
import { get, onChange } from './core/colorMode';
import { styledResolvedToOrderedSXResolved } from './resolver/orderedResolved';
import { styledToStyledResolved } from './resolver/styledResolved';
import { getStyleIds } from './resolver/getStyleIds';
import { injectComponentAndDescendantStyles } from './resolver/injectComponentAndDescendantStyles';
import { resolvePlatformTheme } from './utils';
import { convertStyledToStyledVerbosed, convertSxToSxVerbosed } from './convertSxToSxVerbosed';
import { stableHash } from './stableHash';
import { GluestackStyleSheet } from './style-sheet';
import { CSSPropertiesMap, reservedKeys as _reservedKeys } from './core/styled-system';
import { updateOrderUnResolvedMap } from './updateOrderUnResolvedMap';
import { resolveComponentTheme } from './createConfig';

// Create a caching object
let sxMemoizationCache = {};
const styledSystemProps = {
  ...CSSPropertiesMap
};
function isSubset(subset, set) {
  return subset.every(item => set.includes(item));
}
function flattenObject(obj = {}) {
  const flat = {};

  // Recursive function to flatten the object
  function flatten(obj, path = []) {
    // Iterate over the object's keys

    if (Array.isArray(obj)) {
      flat[`${path.join('.')}`] = obj;
    } else {
      for (const key of Object.keys(obj)) {
        // If the value is an object, recurse
        if (key === 'ids' && path.length > 0) {
          flat[`${path.join('.')}`] = obj[key];
        } else if (key === 'props') {
          flat[`${path.join('.')}.${key}`] = obj[key];
        } else if (typeof obj[key] === 'object') {
          flatten(obj[key], [...path, key]);
        } else {
          flat[`${path.join('.')}`] = obj[key];
        }
      }
    }
  }
  flatten(obj);
  return flat;
}
function convertUtiltiyToSXFromProps(componentProps, styledSystemProps, componentStyleConfig, reservedKeys = _reservedKeys, plugins = [], ignoreKeys = new Set(), Component = null, ExtendedConfig = {}) {
  const {
    sx: userSX,
    ...componentRestProps
  } = componentProps;
  const {
    sxProps: utilityResolvedSX,
    mergedProps: restProps
  } = convertUtilityPropsToSX(styledSystemProps, componentStyleConfig === null || componentStyleConfig === void 0 ? void 0 : componentStyleConfig.descendantStyle, componentRestProps, reservedKeys);
  let resolvedSxVerbose = deepMergeObjects(utilityResolvedSX, userSX);
  let sxIgnoreKeys = new Set();
  if (plugins) {
    var _sxIgnoreKeys;
    for (const pluginName in plugins) {
      var _plugins$pluginName;
      if ((_plugins$pluginName = plugins[pluginName]) !== null && _plugins$pluginName !== void 0 && _plugins$pluginName.inputMiddleWare) {
        var _plugins$pluginName2;
        // @ts-ignore
        [resolvedSxVerbose,,,, sxIgnoreKeys] = (_plugins$pluginName2 = plugins[pluginName]) === null || _plugins$pluginName2 === void 0 ? void 0 : _plugins$pluginName2.inputMiddleWare(resolvedSxVerbose, false, false, Component, componentStyleConfig, ExtendedConfig);
      }
    }
    (_sxIgnoreKeys = sxIgnoreKeys) === null || _sxIgnoreKeys === void 0 || _sxIgnoreKeys.forEach(element => {
      ignoreKeys.add(element);
    });
  }
  const resolvedSXVerbosed = convertSxToSxVerbosed(resolvedSxVerbose);
  return {
    sx: resolvedSXVerbosed,
    nonVerbosedSx: resolvedSxVerbose,
    rest: restProps
  };
}
function getStateStyleCSSFromStyleIdsAndProps(flatternStyleIdObject, currentStateArray, activeThemes = []) {
  const stateStyleCSSIds = [];
  let props = {};
  Object.keys(flatternStyleIdObject).forEach(styleId => {
    const styleIdKeyArray = styleId.split('.');
    const filteredStyleIdKeyArray = styleIdKeyArray.filter(item => item !== 'state' && item !== 'props' && item !== 'theme' && !activeThemes.includes(item));
    if (styleId.includes('ids')) {
      // if (type === 'inline' && ) {
      // stateStyleCSSIds.push(...flatternStyleIdObject[styleId]);
      // }
    } else if (styleId.includes('props') && isSubset(filteredStyleIdKeyArray, currentStateArray)) {
      props = deepMergeObjects(props, flatternStyleIdObject[styleId]);
    } else {
      if (isSubset(filteredStyleIdKeyArray, currentStateArray)) {
        stateStyleCSSIds.push(...flatternStyleIdObject[styleId]);
      }
    }
  });
  return {
    cssIds: stateStyleCSSIds,
    passingProps: props
  };
}
export function resolveBuildTimeSx(userSX, verboseSx, utilityResolvedSX, componentExtendedConfig) {
  const resolvedSXVerbosed = convertSxToSxVerbosed(userSX);
  const resolvedSxVerbose = deepMerge(utilityResolvedSX, resolvedSXVerbosed);
  const sx = deepMerge(resolvedSxVerbose, verboseSx);
  let STABLEHASH_sx = stableHash(sx);
  let orderedSXResolved = [];
  if (Object.keys(sx).length > 0) {
    const inlineSxTheme = {
      baseStyle: sx
    };
    resolvePlatformTheme(inlineSxTheme, Platform.OS);
    const sxStyledResolved = styledToStyledResolved(
    // @ts-ignore
    inlineSxTheme, [], componentExtendedConfig);
    orderedSXResolved = styledResolvedToOrderedSXResolved(sxStyledResolved);
  }
  return {
    orderedSXResolved,
    STABLEHASH_sx
  };
}
function isValidVariantCondition(condition, variants) {
  for (const key in condition) {
    if (!variants.hasOwnProperty(key) || variants[key] !== condition[key]) {
      return false;
    }
  }
  return true;
}
function getMergedDefaultCSSIdsAndProps(componentStyleIds, incomingVariantProps, theme, properties, activeThemes = []) {
  var _componentStyleIds$ba;
  // console.setStartTimeStamp('getMergedDefaultCSSIdsAndProps');

  let props = {};
  const baseStyleCSSIds = [];
  const variantStyleCSSIds = [];
  if (componentStyleIds && componentStyleIds !== null && componentStyleIds !== void 0 && componentStyleIds.baseStyle && componentStyleIds !== null && componentStyleIds !== void 0 && (_componentStyleIds$ba = componentStyleIds.baseStyle) !== null && _componentStyleIds$ba !== void 0 && _componentStyleIds$ba.ids) {
    var _componentStyleIds$ba2, _componentStyleIds$ba3;
    baseStyleCSSIds.push(...(componentStyleIds === null || componentStyleIds === void 0 || (_componentStyleIds$ba2 = componentStyleIds.baseStyle) === null || _componentStyleIds$ba2 === void 0 ? void 0 : _componentStyleIds$ba2.ids));
    props = deepMergeObjects(props, componentStyleIds === null || componentStyleIds === void 0 || (_componentStyleIds$ba3 = componentStyleIds.baseStyle) === null || _componentStyleIds$ba3 === void 0 ? void 0 : _componentStyleIds$ba3.props);
    activeThemes.forEach(currentTheme => {
      var _componentStyleIds$ba4;
      if (componentStyleIds !== null && componentStyleIds !== void 0 && (_componentStyleIds$ba4 = componentStyleIds.baseStyle) !== null && _componentStyleIds$ba4 !== void 0 && (_componentStyleIds$ba4 = _componentStyleIds$ba4.theme) !== null && _componentStyleIds$ba4 !== void 0 && _componentStyleIds$ba4[currentTheme]) {
        var _componentStyleIds$ba5, _componentStyleIds$ba6;
        baseStyleCSSIds.push(
        //@ts-ignore
        ...(componentStyleIds === null || componentStyleIds === void 0 || (_componentStyleIds$ba5 = componentStyleIds.baseStyle) === null || _componentStyleIds$ba5 === void 0 || (_componentStyleIds$ba5 = _componentStyleIds$ba5.theme) === null || _componentStyleIds$ba5 === void 0 || (_componentStyleIds$ba5 = _componentStyleIds$ba5[currentTheme]) === null || _componentStyleIds$ba5 === void 0 ? void 0 : _componentStyleIds$ba5.ids));
        props = deepMergeObjects(props, componentStyleIds === null || componentStyleIds === void 0 || (_componentStyleIds$ba6 = componentStyleIds.baseStyle) === null || _componentStyleIds$ba6 === void 0 || (_componentStyleIds$ba6 = _componentStyleIds$ba6.theme) === null || _componentStyleIds$ba6 === void 0 || (_componentStyleIds$ba6 = _componentStyleIds$ba6[currentTheme]) === null || _componentStyleIds$ba6 === void 0 ? void 0 : _componentStyleIds$ba6.props);
      }
    });
  }
  let passingVariantProps = {};

  // if (props) {
  passingVariantProps = getVariantProps(props, theme).variantProps;
  // }

  const mergedVariantProps = shallowMerge({
    ...passingVariantProps
  }, incomingVariantProps);
  Object.keys(mergedVariantProps).forEach(variant => {
    var _componentStyleIds$va;
    const variantName = mergedVariantProps[variant];
    if (variant && componentStyleIds !== null && componentStyleIds !== void 0 && componentStyleIds.variants && componentStyleIds !== null && componentStyleIds !== void 0 && componentStyleIds.variants[variant] && componentStyleIds !== null && componentStyleIds !== void 0 && (_componentStyleIds$va = componentStyleIds.variants[variant]) !== null && _componentStyleIds$va !== void 0 && _componentStyleIds$va[variantName]) {
      var _componentStyleIds$va2;
      if (componentStyleIds !== null && componentStyleIds !== void 0 && (_componentStyleIds$va2 = componentStyleIds.variants[variant]) !== null && _componentStyleIds$va2 !== void 0 && (_componentStyleIds$va2 = _componentStyleIds$va2[variantName]) !== null && _componentStyleIds$va2 !== void 0 && _componentStyleIds$va2.ids) {
        var _componentStyleIds$va3, _componentStyleIds$va4;
        variantStyleCSSIds.push(
        //@ts-ignore
        ...(componentStyleIds === null || componentStyleIds === void 0 || (_componentStyleIds$va3 = componentStyleIds.variants[variant]) === null || _componentStyleIds$va3 === void 0 || (_componentStyleIds$va3 = _componentStyleIds$va3[variantName]) === null || _componentStyleIds$va3 === void 0 ? void 0 : _componentStyleIds$va3.ids));

        // if this variant exist in remaining props, remove it from remaining props
        if (properties[variant]) {
          delete properties[variant];
        }
        if (props[variant]) {
          delete props[variant];
        }
        props = deepMergeObjects(props, componentStyleIds === null || componentStyleIds === void 0 || (_componentStyleIds$va4 = componentStyleIds.variants[variant]) === null || _componentStyleIds$va4 === void 0 || (_componentStyleIds$va4 = _componentStyleIds$va4[variantName]) === null || _componentStyleIds$va4 === void 0 ? void 0 : _componentStyleIds$va4.props);
      }
      activeThemes.forEach(currentTheme => {
        var _componentStyleIds$va5;
        if (componentStyleIds !== null && componentStyleIds !== void 0 && (_componentStyleIds$va5 = componentStyleIds.variants[variant]) !== null && _componentStyleIds$va5 !== void 0 && (_componentStyleIds$va5 = _componentStyleIds$va5[variantName]) !== null && _componentStyleIds$va5 !== void 0 && (_componentStyleIds$va5 = _componentStyleIds$va5.theme) !== null && _componentStyleIds$va5 !== void 0 && _componentStyleIds$va5[currentTheme]) {
          var _componentStyleIds$va6, _componentStyleIds$va7;
          variantStyleCSSIds.push(...(componentStyleIds === null || componentStyleIds === void 0 || (_componentStyleIds$va6 = componentStyleIds.variants[variant]) === null || _componentStyleIds$va6 === void 0 || (_componentStyleIds$va6 = _componentStyleIds$va6[variantName]) === null || _componentStyleIds$va6 === void 0 || (_componentStyleIds$va6 = _componentStyleIds$va6.theme) === null || _componentStyleIds$va6 === void 0 || (_componentStyleIds$va6 = _componentStyleIds$va6[currentTheme]) === null || _componentStyleIds$va6 === void 0 ? void 0 : _componentStyleIds$va6.ids));
          props = deepMergeObjects(props, componentStyleIds === null || componentStyleIds === void 0 || (_componentStyleIds$va7 = componentStyleIds.variants[variant]) === null || _componentStyleIds$va7 === void 0 || (_componentStyleIds$va7 = _componentStyleIds$va7[variantName]) === null || _componentStyleIds$va7 === void 0 || (_componentStyleIds$va7 = _componentStyleIds$va7.theme) === null || _componentStyleIds$va7 === void 0 || (_componentStyleIds$va7 = _componentStyleIds$va7[currentTheme]) === null || _componentStyleIds$va7 === void 0 ? void 0 : _componentStyleIds$va7.props);
        }
      });
    }
  });
  componentStyleIds === null || componentStyleIds === void 0 || componentStyleIds.compoundVariants.forEach(compoundVariant => {
    if (isValidVariantCondition(compoundVariant.condition, mergedVariantProps)) {
      if (compoundVariant.ids) {
        variantStyleCSSIds.push(
        //@ts-ignore
        ...compoundVariant.ids);
      }
      props = deepMergeObjects(props, compoundVariant === null || compoundVariant === void 0 ? void 0 : compoundVariant.props);
      activeThemes.forEach(currentTheme => {
        var _compoundVariant$them;
        if ((_compoundVariant$them = compoundVariant.theme) !== null && _compoundVariant$them !== void 0 && _compoundVariant$them[currentTheme]) {
          var _compoundVariant$them2, _compoundVariant$them3;
          variantStyleCSSIds.push(
          // @ts-ignore
          ...((_compoundVariant$them2 = compoundVariant.theme) === null || _compoundVariant$them2 === void 0 || (_compoundVariant$them2 = _compoundVariant$them2[currentTheme]) === null || _compoundVariant$them2 === void 0 ? void 0 : _compoundVariant$them2.ids));
          props = deepMergeObjects(props, // @ts-ignore
          (_compoundVariant$them3 = compoundVariant.theme) === null || _compoundVariant$them3 === void 0 || (_compoundVariant$them3 = _compoundVariant$them3[currentTheme]) === null || _compoundVariant$them3 === void 0 ? void 0 : _compoundVariant$them3.props);
        }
      });
    }
  });

  // console.setEndTimeStamp('getMergedDefaultCSSIdsAndProps');

  return {
    baseStyleCSSIds: baseStyleCSSIds,
    variantStyleCSSIds: variantStyleCSSIds,
    passingProps: props
  };
}
const getMergeDescendantsStyleCSSIdsAndPropsWithKey = (descendantStyles, variantProps, theme, properties, activeTheme) => {
  // console.setStartTimeStamp('getMergeDescendantsStyleCSSIdsAndPropsWithKey');

  const descendantStyleObj = {};
  if (descendantStyles) {
    var _Object$keys;
    (_Object$keys = Object.keys(descendantStyles)) === null || _Object$keys === void 0 || _Object$keys.forEach(key => {
      const styleObj = descendantStyles[key];
      const {
        baseStyleCSSIds,
        variantStyleCSSIds,
        passingProps: defaultPassingProps
      } = getMergedDefaultCSSIdsAndProps(styleObj, variantProps, theme, properties, activeTheme);
      descendantStyleObj[key] = {
        baseStyleCSSIds: baseStyleCSSIds,
        variantStyleCSSIds: variantStyleCSSIds,
        passingProps: defaultPassingProps
      };
    });
  }
  // console.setEndTimeStamp('getMergeDescendantsStyleCSSIdsAndPropsWithKey');

  return descendantStyleObj;
};
const AncestorStyleContext = /*#__PURE__*/React.createContext({
  sx: {},
  component: {}
});
//

// window['globalStyleMap'] = globalStyleMap;
// const globalOrderedList: any = [];
// setTimeout(() => {
//   const orderedList = globalOrderedList.sort(
//     (a: any, b: any) => a.meta.weight - b.meta.weight
//   );
//   injectInStyle(orderedList);
// });

function getFlattenStyleObjectFromStyleIds(styleIds) {
  var _styleIds$compoundVar;
  const componentBaseStyleFlatternStyleIdObject = flattenObject(styleIds === null || styleIds === void 0 ? void 0 : styleIds.baseStyle);
  const componentVariantFlatternStyleIdObject = {};
  const componentCompoundVariantFlatternStyleIdObject = [];
  const variantKeys = Object.keys((styleIds === null || styleIds === void 0 ? void 0 : styleIds.variants) ?? {});
  variantKeys.forEach(variant => {
    Object.keys(styleIds === null || styleIds === void 0 ? void 0 : styleIds.variants[variant]).forEach(currentVariant => {
      const flatternVariantStyle = flattenObject(styleIds === null || styleIds === void 0 ? void 0 : styleIds.variants[variant][currentVariant]);
      componentVariantFlatternStyleIdObject[`${variant}.${currentVariant}`] = flatternVariantStyle;
    });
  });
  styleIds === null || styleIds === void 0 || (_styleIds$compoundVar = styleIds.compoundVariants) === null || _styleIds$compoundVar === void 0 || _styleIds$compoundVar.forEach(compoundVariant => {
    componentCompoundVariantFlatternStyleIdObject.push(flattenObject(compoundVariant));
  });
  return {
    componentBaseStyleFlatternStyleIdObject,
    componentVariantFlatternStyleIdObject,
    componentCompoundVariantFlatternStyleIdObject
  };
}
function push_unique(arr, ele) {
  if (Array.isArray(arr)) {
    if (Array.isArray(ele)) {
      ele.forEach(element => {
        if (!arr.includes(element)) {
          arr.push(element);
        }
      });
    } else {
      if (!arr.includes(ele)) {
        arr.push(ele);
      }
    }
  }
  return arr;
}
function setStateAndColorModeCssIdsAndProps(colorMode, states, variantProps, theme, componentStyleIds, sxComponentStyleIds, componentBaseStyleFlatternStyleIdObject, componentVariantFlatternStyleIdObject, componentCompoundVariantFlatternStyleIdObject, componentDescendantFlattenStyleObject, sxBaseStyleFlatternStyleObject, sxVariantFlatternStyleObject, sxCompoundVariantFlatternStyleObject, sxDescendantFlattenStyleObject, componentDescendantStyleIds, sxDescendantStyleIds, activeThemes) {
  if (!componentStyleIds) {
    return {
      baseStyleCSSIds: [],
      variantStyleCSSIds: [],
      passingProps: {}
    };
  }
  let stateColorMode = {};
  let currentStateArray = [];
  if (colorMode || states) {
    stateColorMode = {
      ...states,
      [colorMode]: true
    };
    currentStateArray = Object.keys(stateColorMode).filter(key => stateColorMode[key] === true);
  }
  const {
    baseStyleCSSIds: mergedBaseStyleCSSIds,
    variantStyleCSSIds: mergedVariantStyleCSSIds,
    passingProps: stateProps
  } = getMergedStateAndColorModeCSSIdsAndProps(componentStyleIds,
  //@ts-ignore
  componentBaseStyleFlatternStyleIdObject, states, variantProps, colorMode, theme, componentVariantFlatternStyleIdObject, componentCompoundVariantFlatternStyleIdObject, currentStateArray, activeThemes);

  // for sx props
  const {
    baseStyleCSSIds: mergedSXBaseStyleCSSIds,
    variantStyleCSSIds: mergedSXVariantStyleCSSIds,
    passingProps: mergedSxStateProps
  } = getMergedStateAndColorModeCSSIdsAndProps(sxComponentStyleIds.current,
  //@ts-ignore
  sxBaseStyleFlatternStyleObject, states, variantProps, colorMode, theme, sxVariantFlatternStyleObject, sxCompoundVariantFlatternStyleObject, currentStateArray, activeThemes);

  // for descendants
  const mergedDescendantsStyle = {};
  if (componentDescendantStyleIds && Object.keys(componentDescendantStyleIds).length > 0) {
    Object.keys(componentDescendantStyleIds).forEach(key => {
      var _componentDescendantF, _componentDescendantF2, _componentDescendantF3;
      const {
        baseStyleCSSIds: descendantBaseStyleCSSIds,
        variantStyleCSSIds: descendantVariantStyleCSSIds,
        passingProps: mergedPassingProps
      } = getMergedStateAndColorModeCSSIdsAndProps(
      //@ts-ignore
      componentDescendantStyleIds[key], (_componentDescendantF = componentDescendantFlattenStyleObject[key]) === null || _componentDescendantF === void 0 ? void 0 : _componentDescendantF['componentBaseStyleFlatternStyleIdObject'], states, variantProps, colorMode, theme, (_componentDescendantF2 = componentDescendantFlattenStyleObject[key]) === null || _componentDescendantF2 === void 0 ? void 0 : _componentDescendantF2['componentVariantFlatternStyleIdObject'], (_componentDescendantF3 = componentDescendantFlattenStyleObject[key]) === null || _componentDescendantF3 === void 0 ? void 0 : _componentDescendantF3['componentCompoundVariantFlatternStyleIdObject'], currentStateArray, activeThemes);
      mergedDescendantsStyle[key] = {
        baseStyleCSSIds: descendantBaseStyleCSSIds,
        variantStyleCSSIds: descendantVariantStyleCSSIds,
        passingProps: mergedPassingProps
      };
    });
  }

  // for sx descendants
  const mergedSxDescendantsStyle = {};
  if (sxDescendantStyleIds.current && Object.keys(sxDescendantStyleIds.current).length > 0) {
    Object.keys(sxDescendantStyleIds.current).forEach(key => {
      var _sxDescendantFlattenS, _sxDescendantFlattenS2, _sxDescendantFlattenS3;
      const {
        baseStyleCSSIds: sxDescendantBaseStyleCSSIds,
        variantStyleCSSIds: sxDescendantVariantStyleCSSIds,
        passingProps: mergedPassingProps
      } = getMergedStateAndColorModeCSSIdsAndProps(
      //@ts-ignore
      sxDescendantStyleIds.current[key], (_sxDescendantFlattenS = sxDescendantFlattenStyleObject[key]) === null || _sxDescendantFlattenS === void 0 ? void 0 : _sxDescendantFlattenS['componentBaseStyleFlatternStyleIdObject'], states, variantProps, colorMode, theme, (_sxDescendantFlattenS2 = sxDescendantFlattenStyleObject[key]) === null || _sxDescendantFlattenS2 === void 0 ? void 0 : _sxDescendantFlattenS2['componentVariantFlatternStyleIdObject'], (_sxDescendantFlattenS3 = sxDescendantFlattenStyleObject[key]) === null || _sxDescendantFlattenS3 === void 0 ? void 0 : _sxDescendantFlattenS3['componentCompoundVariantFlatternStyleIdObject'], currentStateArray, activeThemes);
      mergedSxDescendantsStyle[key] = {
        baseStyleCSSIds: sxDescendantBaseStyleCSSIds,
        variantStyleCSSIds: sxDescendantVariantStyleCSSIds,
        passingProps: mergedPassingProps
      };
    });
  }
  return {
    mergedSXBaseStyleCSSIds,
    mergedSXVariantStyleCSSIds,
    mergedSxStateProps,
    mergedBaseStyleCSSIds,
    mergedVariantStyleCSSIds,
    stateProps,
    mergedSxDescendantsStyle,
    mergedDescendantsStyle
  };
}
function getMergedStateAndColorModeCSSIdsAndProps(componentStyleIds, componentBaseStyleFlatternStyleIdObject, _states, incomingVariantProps, _COLOR_MODE, theme, componentVariantFlatternStyleIdObject, componentCompoundVariantFlatternStyleIdObject, currentStateArray, activeThemes = []) {
  if (!componentStyleIds) {
    return {
      baseStyleCSSIds: [],
      variantStyleCSSIds: [],
      passingProps: {}
    };
  }
  const stateBaseStyleCSSIds = [];
  const stateVariantStyleCSSIds = [];
  let props = {};
  if (componentBaseStyleFlatternStyleIdObject) {
    const {
      cssIds: stateStleCSSFromStyleIds,
      passingProps: stateStyleProps
    } = getStateStyleCSSFromStyleIdsAndProps(componentBaseStyleFlatternStyleIdObject, currentStateArray, activeThemes);
    push_unique(stateBaseStyleCSSIds, stateStleCSSFromStyleIds);
    // stateBaseStyleCSSIds.push(...stateStleCSSFromStyleIds);
    props = deepMergeObjects(props, stateStyleProps);
  }
  let passingVariantProps = getVariantProps(props, theme).variantProps;
  const mergedVariantProps = shallowMerge({
    ...passingVariantProps
  }, incomingVariantProps);
  if (componentVariantFlatternStyleIdObject) {
    Object.keys(mergedVariantProps).forEach(variant => {
      const variantObjectPath = `${variant}.${mergedVariantProps[variant]}`;
      if (variant && componentVariantFlatternStyleIdObject !== null && componentVariantFlatternStyleIdObject !== void 0 && componentVariantFlatternStyleIdObject[variantObjectPath]) {
        const {
          cssIds: stateStleCSSFromStyleIds,
          passingProps: stateStyleProps
        } = getStateStyleCSSFromStyleIdsAndProps(componentVariantFlatternStyleIdObject[variantObjectPath], currentStateArray);
        push_unique(stateVariantStyleCSSIds, stateStleCSSFromStyleIds);
        props = deepMergeObjects(props, stateStyleProps);
        activeThemes.forEach(currentTheme => {
          var _componentVariantFlat;
          if (componentVariantFlatternStyleIdObject !== null && componentVariantFlatternStyleIdObject !== void 0 && (_componentVariantFlat = componentVariantFlatternStyleIdObject[variantObjectPath]) !== null && _componentVariantFlat !== void 0 && (_componentVariantFlat = _componentVariantFlat.theme) !== null && _componentVariantFlat !== void 0 && _componentVariantFlat[currentTheme]) {
            var _componentVariantFlat2;
            const {
              cssIds: stateStleCSSFromStyleIds,
              passingProps: stateStyleProps
            } = getStateStyleCSSFromStyleIdsAndProps(componentVariantFlatternStyleIdObject === null || componentVariantFlatternStyleIdObject === void 0 || (_componentVariantFlat2 = componentVariantFlatternStyleIdObject[variantObjectPath]) === null || _componentVariantFlat2 === void 0 || (_componentVariantFlat2 = _componentVariantFlat2.theme) === null || _componentVariantFlat2 === void 0 ? void 0 : _componentVariantFlat2[currentTheme], currentStateArray);
            push_unique(stateVariantStyleCSSIds, stateStleCSSFromStyleIds);
            props = deepMergeObjects(props, stateStyleProps);
          }
        });
      }
    });
  }
  if (componentCompoundVariantFlatternStyleIdObject.length > 0) {
    var _componentStyleIds$co;
    componentStyleIds === null || componentStyleIds === void 0 || (_componentStyleIds$co = componentStyleIds.compoundVariants) === null || _componentStyleIds$co === void 0 || _componentStyleIds$co.forEach((compoundVariant, index) => {
      if (isValidVariantCondition(compoundVariant.condition, mergedVariantProps)) {
        const {
          cssIds: stateStleCSSFromStyleIds,
          passingProps: stateStyleProps
        } = getStateStyleCSSFromStyleIdsAndProps(componentCompoundVariantFlatternStyleIdObject[index], currentStateArray);
        push_unique(stateVariantStyleCSSIds, stateStleCSSFromStyleIds);
        props = deepMergeObjects(props, stateStyleProps);
        activeThemes.forEach(currentTheme => {
          var _compoundVariant$them4;
          if ((_compoundVariant$them4 = compoundVariant.theme) !== null && _compoundVariant$them4 !== void 0 && _compoundVariant$them4[currentTheme]) {
            var _compoundVariant$them5;
            const {
              cssIds: stateStleCSSFromStyleIds,
              passingProps: stateStyleProps
            } = getStateStyleCSSFromStyleIdsAndProps((_compoundVariant$them5 = compoundVariant.theme) === null || _compoundVariant$them5 === void 0 ? void 0 : _compoundVariant$them5[currentTheme], currentStateArray);
            push_unique(stateVariantStyleCSSIds, stateStleCSSFromStyleIds);
            props = deepMergeObjects(props, stateStyleProps);
          }
        });
      }
    });
  }
  return {
    baseStyleCSSIds: stateBaseStyleCSSIds,
    variantStyleCSSIds: stateVariantStyleCSSIds,
    passingProps: props
  };
}
function getAncestorCSSStyleIds(compConfig, context) {
  var _compConfig$ancestorS;
  let ancestorBaseStyleIds = [];
  let ancestorVariantStyleIds = [];
  let ancestorPassingProps = {};
  if (((_compConfig$ancestorS = compConfig.ancestorStyle) === null || _compConfig$ancestorS === void 0 ? void 0 : _compConfig$ancestorS.length) > 0) {
    if (context) {
      compConfig.ancestorStyle.forEach(ancestor => {
        if (context[ancestor]) {
          var _context$ancestor, _context$ancestor2, _context$ancestor3;
          ancestorBaseStyleIds = (_context$ancestor = context[ancestor]) === null || _context$ancestor === void 0 ? void 0 : _context$ancestor.baseStyleCSSIds;
          ancestorVariantStyleIds = (_context$ancestor2 = context[ancestor]) === null || _context$ancestor2 === void 0 ? void 0 : _context$ancestor2.variantStyleCSSIds;
          ancestorPassingProps = (_context$ancestor3 = context[ancestor]) === null || _context$ancestor3 === void 0 ? void 0 : _context$ancestor3.passingProps;
        }
      });
    }
  }
  return {
    baseStyleCSSIds: ancestorBaseStyleIds,
    variantStyleIds: ancestorVariantStyleIds,
    passingProps: ancestorPassingProps
  };
}
function mergeArraysInObjects(...objects) {
  const merged = {};
  for (const object of objects) {
    Object.keys(object).forEach(key => {
      const value = object[key];
      if (!merged[key]) {
        merged[key] = {
          baseStyleCSSIds: [],
          variantStyleCSSIds: [],
          passingProps: {}
        };
      }
      merged[key].baseStyleCSSIds.push(...value.baseStyleCSSIds);
      merged[key].variantStyleCSSIds.push(...value.variantStyleCSSIds);
      merged[key].passingProps = deepMergeObjects(merged[key].passingProps, value.passingProps);
    });
  }
  return merged;
}
export function getVariantProps(props, theme, shouldDeleteVariants = true) {
  const variantTypes = theme !== null && theme !== void 0 && theme.variants ? Object.keys(theme.variants) : [];
  const variantProps = {};
  const restProps = {
    ...props
  };
  if (restProps) {
    variantTypes === null || variantTypes === void 0 || variantTypes.forEach(variant => {
      var _theme$variants$varia;
      if (props.hasOwnProperty(variant) && (_theme$variants$varia = theme.variants[variant]) !== null && _theme$variants$varia !== void 0 && _theme$variants$varia[props[variant]]) {
        variantProps[variant] = props[variant];
        if (shouldDeleteVariants) {
          delete restProps[variant];
        }
      }
    });
  }
  return {
    variantProps,
    restProps
  };
}
function resolveInlineProps(componentStyleConfig, componentExtendedConfig, props, CONFIG) {
  let resolvedInlineProps = {};
  if (componentStyleConfig.resolveProps && Object.keys(componentExtendedConfig).length > 0) {
    componentStyleConfig.resolveProps.forEach(toBeResovledProp => {
      if (props[toBeResovledProp]) {
        let value = props[toBeResovledProp];
        if (CONFIG.propertyResolver && CONFIG.propertyResolver.props && CONFIG.propertyResolver.props[toBeResovledProp]) {
          let transformer = CONFIG.propertyResolver.props[toBeResovledProp];
          let aliasTokenType = CONFIG.propertyTokenMap[toBeResovledProp];
          let token = transformer(value, (value1, scale = aliasTokenType) => resolveStringToken(value1, CONFIG, CONFIG.propertyTokenMap, toBeResovledProp, scale, Platform.OS !== 'web'));

          //@ts-ignore
          resolvedInlineProps[toBeResovledProp] = token;
        } else {
          //@ts-ignore
          resolvedInlineProps[toBeResovledProp] = getResolvedTokenValueFromConfig(componentExtendedConfig, props, toBeResovledProp, props[toBeResovledProp], Platform.OS !== 'web');
        }
        delete props[toBeResovledProp];
      }
    });
  }
  return resolvedInlineProps;
}
const getStyleIdsFromMap = (CONFIG, ExtendedConfig, styleIds) => {
  var _componentExtendedCon;
  let componentExtendedConfig = CONFIG;
  if (ExtendedConfig) {
    componentExtendedConfig = deepMergeObjects(CONFIG, ExtendedConfig);
  }
  Object.assign(styledSystemProps, (_componentExtendedCon = componentExtendedConfig) === null || _componentExtendedCon === void 0 ? void 0 : _componentExtendedCon.aliases);
  const componentStyleIds = styleIds.component;
  const componentDescendantStyleIds = styleIds.descendant;
  const {
    componentBaseStyleFlatternStyleIdObject,
    componentVariantFlatternStyleIdObject,
    componentCompoundVariantFlatternStyleIdObject
  } = getFlattenStyleObjectFromStyleIds(componentStyleIds);
  const descendantFlattenStyles = {};
  if (componentDescendantStyleIds) {
    Object.keys(componentDescendantStyleIds).forEach(currentDescendant => {
      descendantFlattenStyles[currentDescendant] = getFlattenStyleObjectFromStyleIds(componentDescendantStyleIds[currentDescendant]);
    });
  }
  const componentStyleObject = {
    componentStyleIds,
    componentDescendantStyleIds,
    componentExtendedConfig,
    componentBaseStyleFlatternStyleIdObject,
    componentVariantFlatternStyleIdObject,
    componentCompoundVariantFlatternStyleIdObject,
    descendantFlattenStyles
  };
  return componentStyleObject;
};
export function verboseStyled(Component, theme, componentStyleConfig = {}, ExtendedConfig, BUILD_TIME_PARAMS, nonVerbosedTheme) {
  var _componentStyleConfig;
  // const componentName = componentStyleConfig?.componentName;
  const componentHash = stableHash({
    ...theme,
    ...componentStyleConfig,
    ...ExtendedConfig
  });
  let declarationType = 'boot';
  if ((Component === null || Component === void 0 ? void 0 : Component.displayName) === '__AsForwarder__') {
    declarationType = 'forwarded';
  }
  resolvePlatformTheme(theme, Platform.OS);

  // const DEBUG_TAG = componentStyleConfig?.DEBUG;
  // const DEBUG =
  //   process.env.NODE_ENV === 'development' && DEBUG_TAG ? false : false;

  //@ts-ignore

  let styleHashCreated = false;
  let pluginData;
  let orderedResolved;
  let componentStyleIds = {};
  let componentDescendantStyleIds = {}; // StyleIds = {};
  let componentExtendedConfig = {};
  let componentBaseStyleFlatternStyleIdObject = {};
  let componentVariantFlatternStyleIdObject = {};
  let componentCompoundVariantFlatternStyleIdObject = [];
  let componentDescendantFlattenStyles = {};
  let styleIds = {};
  let orderedCSSIds = [];
  //@ts-ignore
  const isStyledComponent = Component === null || Component === void 0 ? void 0 : Component.isStyledComponent;
  // const orderedUnResolvedTheme = updateOrderUnResolvedMap(
  //   theme,
  //   componentHash,
  //   declarationType,
  //   ExtendedConfig
  // );

  // styleIds = getStyleIds(orderedUnResolvedTheme, componentStyleConfig);

  if (BUILD_TIME_PARAMS !== null && BUILD_TIME_PARAMS !== void 0 && BUILD_TIME_PARAMS.orderedResolved) {
    orderedResolved = BUILD_TIME_PARAMS === null || BUILD_TIME_PARAMS === void 0 ? void 0 : BUILD_TIME_PARAMS.orderedResolved;
    orderedCSSIds = BUILD_TIME_PARAMS === null || BUILD_TIME_PARAMS === void 0 ? void 0 : BUILD_TIME_PARAMS.styledIds;
    BUILD_TIME_PARAMS.toBeInjected = GluestackStyleSheet.update(orderedResolved);
  } else {
    const {
      styledIds: g,
      verbosedStyleIds
    } = updateOrderUnResolvedMap({
      ...theme
    }, componentHash, declarationType, componentStyleConfig, GluestackStyleSheet, Platform.OS, isStyledComponent);
    orderedCSSIds = g;
    styleIds = verbosedStyleIds;
  }
  if (BUILD_TIME_PARAMS !== null && BUILD_TIME_PARAMS !== void 0 && BUILD_TIME_PARAMS.verbosedStyleIds) {
    styleIds = BUILD_TIME_PARAMS === null || BUILD_TIME_PARAMS === void 0 ? void 0 : BUILD_TIME_PARAMS.verbosedStyleIds;
  }
  function injectSx(sx, type = 'inline', inlineStyleMap, ignoreKeys = new Set()) {
    var _sxStyledResolved$bas;
    const sxHash = stableHash(sx);
    const memoizationKey = sxHash + type;
    // Check if the result is already in the cache
    if (sxMemoizationCache[memoizationKey]) {
      injectComponentAndDescendantStyles(sxMemoizationCache[memoizationKey], sxHash, type, GluestackStyleSheet, Platform.OS, inlineStyleMap, ignoreKeys, CONFIG);
      return sxMemoizationCache[memoizationKey];
    }
    const inlineSxTheme = {
      baseStyle: sx
    };

    // if (Platform.OS === '')
    // console.log(sxHash, GluestackStyleSheet.getStyleMap(), 'hash here');

    resolvePlatformTheme(inlineSxTheme, Platform.OS);
    const sxStyledResolved = styledToStyledResolved(
    // @ts-ignore
    inlineSxTheme, [], componentExtendedConfig);
    let componentTheme =
    // @ts-ignore
    sxStyledResolved.baseStyle.styledValueResolvedWithMeta;

    // sxStyledResolved.baseStyle.styledValueResolvedWithMeta =
    addThemeConditionInMeta(componentTheme, CONFIG);
    const colorModeComponentThemes = (_sxStyledResolved$bas = sxStyledResolved.baseStyle) === null || _sxStyledResolved$bas === void 0 ? void 0 : _sxStyledResolved$bas.colorMode;
    if (colorModeComponentThemes) {
      Object.keys(colorModeComponentThemes).forEach(colorModeComponentTheme => {
        var _colorModeComponentTh;
        if (!((_colorModeComponentTh = colorModeComponentThemes[colorModeComponentTheme].styledValueResolvedWithMeta) !== null && _colorModeComponentTh !== void 0 && _colorModeComponentTh.meta.themeCondition)) {
          colorModeComponentThemes[colorModeComponentTheme].styledValueResolvedWithMeta.meta.themeCondition = {};
        }
        let componentTheme = colorModeComponentThemes[colorModeComponentTheme].styledValueResolvedWithMeta;
        addThemeConditionInMeta(componentTheme, CONFIG);
      });
    }

    // const sxHash = stableHash(sx);

    const orderedSXResolved = styledResolvedToOrderedSXResolved(sxStyledResolved);
    INTERNAL_updateCSSStyleInOrderedResolved(orderedSXResolved, sxHash, true, 'gs');
    injectComponentAndDescendantStyles(orderedSXResolved, sxHash, type, GluestackStyleSheet, Platform.OS, inlineStyleMap, ignoreKeys, CONFIG);
    sxMemoizationCache[memoizationKey] = orderedSXResolved;
    return orderedSXResolved;
  }

  // END BASE COLOR MODE RESOLUTION

  let CONFIG = {};
  let plugins = [];
  let reservedKeys = {
    ..._reservedKeys
  };
  const containsDescendant = (componentStyleConfig === null || componentStyleConfig === void 0 ? void 0 : componentStyleConfig.descendantStyle) && (componentStyleConfig === null || componentStyleConfig === void 0 || (_componentStyleConfig = componentStyleConfig.descendantStyle) === null || _componentStyleConfig === void 0 ? void 0 : _componentStyleConfig.length) > 0;
  let uniqueComponentId = '';
  const StyledComponent = ({
    //@ts-ignore
    orderedResolved: BUILD_TIME_ORDERED_RESOLVED = [],
    //@ts-ignore
    verbosedStyleIds: BUILD_TIME_VERBOSED_STYLE_IDS = {},
    //@ts-ignore
    states,
    // styledIds: BUILD_TIME_STYLE_IDS = [],
    // sxHash: BUILD_TIME_sxHash = '',
    ...componentProps
  }, ref) => {
    var _theme$baseStyle, _passingProps$as;
    const isClient = React.useRef(false);
    const GluestackComponent = useRef(Component);
    if (uniqueComponentId === '') {
      uniqueComponentId = componentHash;
    }
    let ignoreKeys = new Set();

    //@ts-ignore
    let themeDefaultProps = {
      ...((_theme$baseStyle = theme.baseStyle) === null || _theme$baseStyle === void 0 ? void 0 : _theme$baseStyle.props)
    };
    const sxComponentStyleIds = useRef({});
    const sxDescendantStyleIds = useRef({});
    const sxComponentPassingProps = useRef({});
    const applySxBaseStyleCSSIds = useRef([]);
    const applySxVariantStyleCSSIds = useRef([]);
    const applySxDescendantStyleCSSIdsAndPropsWithKey = useRef({});
    const styledContext = useStyled();
    const {
      themes: activeThemes
    } = useTheme();
    const ancestorStyleContext = useContext(AncestorStyleContext);
    let incomingComponentProps = {};
    let applyComponentInlineProps = {};
    const sxBaseStyleFlatternStyleObject = React.useRef({});
    const sxVariantFlatternStyleObject = React.useRef({});
    const sxCompoundVariantFlatternStyleObject = React.useRef({});
    const sxDescendantFlattenStyles = React.useRef({});
    const COLOR_MODE = styledContext._experimentalNestedProvider ? styledContext.colorMode : get();
    if (!styleHashCreated) {
      var _CONFIG, _CONFIG3, _theme, _CONFIG4;
      // eslint-disable-next-line react-hooks/rules-of-hooks

      CONFIG = {
        ...styledContext.config,
        propertyTokenMap
      };
      const prefixedMediaQueries = {};
      if ((_CONFIG = CONFIG) !== null && _CONFIG !== void 0 && (_CONFIG = _CONFIG.tokens) !== null && _CONFIG !== void 0 && _CONFIG.mediaQueries) {
        var _CONFIG2;
        Object.keys((_CONFIG2 = CONFIG) === null || _CONFIG2 === void 0 || (_CONFIG2 = _CONFIG2.tokens) === null || _CONFIG2 === void 0 ? void 0 : _CONFIG2.mediaQueries).forEach(key => {
          prefixedMediaQueries[key] = {
            key: `@${key}`,
            isMediaQuery: true
          };
        });
      }
      Object.assign(reservedKeys, {
        ...prefixedMediaQueries
      });
      // for extended components

      const EXTENDED_THEME = componentStyleConfig.componentName && ((_CONFIG3 = CONFIG) === null || _CONFIG3 === void 0 || (_CONFIG3 = _CONFIG3.components) === null || _CONFIG3 === void 0 ? void 0 : _CONFIG3[componentStyleConfig.componentName]);

      // middleware logic

      let componentExtendedTheme = {};
      nonVerbosedTheme = deepMerge(nonVerbosedTheme, EXTENDED_THEME === null || EXTENDED_THEME === void 0 ? void 0 : EXTENDED_THEME.theme);
      if (CONFIG.plugins) {
        plugins.push(...CONFIG.plugins);
      }
      if (ExtendedConfig !== null && ExtendedConfig !== void 0 && ExtendedConfig.plugins) {
        plugins.push(...(ExtendedConfig === null || ExtendedConfig === void 0 ? void 0 : ExtendedConfig.plugins));
      }
      if (plugins) {
        for (const pluginName in plugins) {
          var _plugins$pluginName3, _themeIgnoreKeys;
          let themeIgnoreKeys = new Set();
          if ((_plugins$pluginName3 = plugins[pluginName]) !== null && _plugins$pluginName3 !== void 0 && _plugins$pluginName3.inputMiddleWare) {
            var _plugins$pluginName4;
            // @ts-ignore
            [nonVerbosedTheme,,,, themeIgnoreKeys] = (_plugins$pluginName4 = plugins[pluginName]) === null || _plugins$pluginName4 === void 0 ? void 0 : _plugins$pluginName4.inputMiddleWare(nonVerbosedTheme, true, true, (componentProps === null || componentProps === void 0 ? void 0 : componentProps.as) ?? Component, {
              ...componentStyleConfig,
              uniqueComponentId
            }, ExtendedConfig);
          }
          (_themeIgnoreKeys = themeIgnoreKeys) === null || _themeIgnoreKeys === void 0 || _themeIgnoreKeys.forEach(ele => {
            ignoreKeys.add(ele);
          });
        }
      }

      // Injecting style
      if (EXTENDED_THEME) {
        // RUN Middlewares

        const resolvedComponentExtendedTheme = resolveComponentTheme(CONFIG, EXTENDED_THEME);
        componentExtendedTheme = resolvedComponentExtendedTheme.theme;

        // const resolvedComponentExtendedTheme = EXTENDED_THEME;

        if (Object.keys((EXTENDED_THEME === null || EXTENDED_THEME === void 0 ? void 0 : EXTENDED_THEME.BUILD_TIME_PARAMS) ?? {}).length > 0) {
          const EXTENDED_THEME_BUILD_TIME_PARAMS = EXTENDED_THEME === null || EXTENDED_THEME === void 0 ? void 0 : EXTENDED_THEME.BUILD_TIME_PARAMS;
          deepMergeArray(styleIds, EXTENDED_THEME_BUILD_TIME_PARAMS === null || EXTENDED_THEME_BUILD_TIME_PARAMS === void 0 ? void 0 : EXTENDED_THEME_BUILD_TIME_PARAMS.verbosedStyleIds);
          GluestackStyleSheet.inject(EXTENDED_THEME_BUILD_TIME_PARAMS === null || EXTENDED_THEME_BUILD_TIME_PARAMS === void 0 ? void 0 : EXTENDED_THEME_BUILD_TIME_PARAMS.toBeInjected, styledContext.inlineStyleMap);
        } else {
          // Merge of Extended Config Style ID's with Component Style ID's
          deepMergeArray(styleIds, resolvedComponentExtendedTheme === null || resolvedComponentExtendedTheme === void 0 ? void 0 : resolvedComponentExtendedTheme.verbosedStyleIds);
          const extendedStylesToBeInjected = GluestackStyleSheet.resolve(resolvedComponentExtendedTheme === null || resolvedComponentExtendedTheme === void 0 ? void 0 : resolvedComponentExtendedTheme.styledIds, CONFIG, componentExtendedConfig, true, 'extended', ignoreKeys);
          GluestackStyleSheet.inject(extendedStylesToBeInjected, styledContext.inlineStyleMap);
        }
      }

      // for extended components end

      //@ts-ignore
      const globalStyle = styledContext.globalStyle;
      if (globalStyle) {
        const {
          globalStyleIds,
          globalVerbosedStyleIds,
          globalTheme
        } = globalStyle;
        theme.variants = deepMerge(theme.variants, globalTheme.variants);
        // Merge of Extended Config Style ID's with Component Style ID's
        deepMergeArray(styleIds, globalVerbosedStyleIds);
        // Injecting Extended StyleSheet from Config
        orderedCSSIds = [...orderedCSSIds, ...globalStyleIds];
      }
      if (!BUILD_TIME_PARAMS || !(BUILD_TIME_PARAMS !== null && BUILD_TIME_PARAMS !== void 0 && BUILD_TIME_PARAMS.orderedResolved) || (BUILD_TIME_PARAMS === null || BUILD_TIME_PARAMS === void 0 ? void 0 : BUILD_TIME_PARAMS.orderedResolved.length) === 0) {
        const toBeInjected = GluestackStyleSheet.resolve(orderedCSSIds, CONFIG, componentExtendedConfig, true, 'boot', ignoreKeys);
        if (Platform.OS === 'web') {
          GluestackStyleSheet.inject(toBeInjected, styledContext.inlineStyleMap);
        }
      } else {
        if (Platform.OS === 'web') {
          //@ts-ignore
          GluestackStyleSheet.inject(BUILD_TIME_PARAMS.toBeInjected, styledContext.inlineStyleMap);
        }
      }
      theme = deepMerge(theme, componentExtendedTheme);
      // @ts-ignore
      Object.assign(themeDefaultProps, (_theme = theme) === null || _theme === void 0 || (_theme = _theme.baseStyle) === null || _theme === void 0 ? void 0 : _theme.props);
      Object.assign(styledSystemProps, (_CONFIG4 = CONFIG) === null || _CONFIG4 === void 0 ? void 0 : _CONFIG4.aliases);
      const {
        componentStyleIds: c,
        componentDescendantStyleIds: d,
        componentExtendedConfig: f,
        componentBaseStyleFlatternStyleIdObject: g,
        componentVariantFlatternStyleIdObject: h,
        componentCompoundVariantFlatternStyleIdObject: i,
        descendantFlattenStyles
      } = getStyleIdsFromMap(CONFIG, ExtendedConfig, styleIds);
      componentStyleIds = c;
      componentDescendantStyleIds = d;
      componentExtendedConfig = f;
      componentBaseStyleFlatternStyleIdObject = g;
      componentVariantFlatternStyleIdObject = h;
      componentCompoundVariantFlatternStyleIdObject = i;
      componentDescendantFlattenStyles = descendantFlattenStyles;
      styleHashCreated = true;

      /* Boot time */
    }
    const {
      passingProps: applyAncestorPassingProps,
      baseStyleCSSIds: applyAncestorBaseStyleCSSIds,
      variantStyleIds: applyAncestorVariantStyleCSSIds
    } = getAncestorCSSStyleIds(componentStyleConfig, ancestorStyleContext.component);
    const {
      passingProps: applySxAncestorPassingProps,
      baseStyleCSSIds: applySxAncestorBaseStyleCSSIds,
      variantStyleIds: applySxAncestorVariantStyleCSSIds
    } = getAncestorCSSStyleIds(componentStyleConfig, ancestorStyleContext.sx);
    Object.assign(incomingComponentProps, applyAncestorPassingProps);
    Object.assign(incomingComponentProps, applySxAncestorPassingProps);
    Object.assign(incomingComponentProps, componentProps);
    const {
      variantProps: defaultVariantProps,
      restProps: defaultThemePropsWithoutVariants
    } = getVariantProps(themeDefaultProps, theme);
    const {
      variantProps: inlineVariantProps,
      restProps: inlineComponentPropsWithoutVariants
    } = getVariantProps(incomingComponentProps, theme);
    const variantProps = Object.assign(defaultVariantProps, inlineVariantProps);
    const {
      baseStyleCSSIds: applyBaseStyleCSSIds,
      variantStyleCSSIds: applyVariantStyleCSSIds,
      passingProps: applyComponentPassingProps
    } = getMergedDefaultCSSIdsAndProps(
    //@ts-ignore
    componentStyleIds, variantProps, theme, incomingComponentProps, activeThemes);
    let mergedBaseStyleCSSIds = [];
    let mergedVariantStyleCSSIds = [];
    let stateProps = [];
    let mergedSXBaseStyleCSSIds = [];
    let mergedSXVariantStyleCSSIds = [];
    let mergedSxStateProps = [];
    let mergedSxDescendantsStyle = {};
    let mergedDescendantsStyle = {};
    let orderedComponentSXResolved = [];
    let orderedPassingSXResolved = [];
    const sxStyleIds = React.useRef(BUILD_TIME_VERBOSED_STYLE_IDS);
    if (BUILD_TIME_ORDERED_RESOLVED.length > 0 && !isClient.current) {
      var _sxStyleIds$current;
      const toBeInjected = GluestackStyleSheet.update(BUILD_TIME_ORDERED_RESOLVED);
      if (Platform.OS === 'web') {
        GluestackStyleSheet.inject(toBeInjected, styledContext.inlineStyleMap);
      }
      sxStyleIds.current = BUILD_TIME_VERBOSED_STYLE_IDS;
      if (!sxStyleIds.current.component) {
        sxStyleIds.current.component = {};
      }
      sxStyleIds.current.component.variants = componentStyleIds.variants;
      //@ts-ignore
      sxStyleIds.current.component.compoundVariants = componentStyleIds.compoundVariants;
      // console.setStartTimeStamp('setColorModeBaseStyleIds');
      sxComponentStyleIds.current = (_sxStyleIds$current = sxStyleIds.current) === null || _sxStyleIds$current === void 0 ? void 0 : _sxStyleIds$current.component;
      sxDescendantStyleIds.current = sxStyleIds.current.descendant;
      // 315ms
      // SX component style
      //@ts-ignore
      const {
        baseStyleCSSIds: sxBaseStyleCSSIds,
        variantStyleCSSIds: sxVariantStyleCSSIds,
        passingProps: sxPassingProps
      } = getMergedDefaultCSSIdsAndProps(
      //@ts-ignore
      sxComponentStyleIds.current, variantProps, theme, incomingComponentProps, activeThemes);
      //@ts-ignore
      // applySxStyleCSSIds.current = sxStyleCSSIds;
      //@ts-ignore
      applySxBaseStyleCSSIds.current = sxBaseStyleCSSIds;
      //@ts-ignore
      applySxVariantStyleCSSIds.current = sxVariantStyleCSSIds;
      sxComponentPassingProps.current = sxPassingProps;
      const {
        componentBaseStyleFlatternStyleIdObject: a,
        componentVariantFlatternStyleIdObject: b,
        componentCompoundVariantFlatternStyleIdObject: c
      } = getFlattenStyleObjectFromStyleIds(sxComponentStyleIds.current);
      if (sxDescendantStyleIds.current && containsDescendant) {
        Object.keys(sxDescendantStyleIds.current).forEach(currentDescendant => {
          sxDescendantFlattenStyles.current[currentDescendant] = getFlattenStyleObjectFromStyleIds(sxDescendantStyleIds.current[currentDescendant]);
        });
      }
      sxBaseStyleFlatternStyleObject.current = a;
      sxVariantFlatternStyleObject.current = b;
      sxCompoundVariantFlatternStyleObject.current = c;
    }
    if (!isClient.current) {
      const {
        mergedBaseStyleCSSIds: a,
        mergedVariantStyleCSSIds: b,
        stateProps: c,
        mergedSXBaseStyleCSSIds: d,
        mergedSXVariantStyleCSSIds: e,
        mergedSxStateProps: f,
        mergedSxDescendantsStyle: g,
        mergedDescendantsStyle: h
      } = setStateAndColorModeCssIdsAndProps(COLOR_MODE, states, variantProps, theme, componentStyleIds, sxComponentStyleIds, componentBaseStyleFlatternStyleIdObject, componentVariantFlatternStyleIdObject, componentCompoundVariantFlatternStyleIdObject, componentDescendantFlattenStyles, sxBaseStyleFlatternStyleObject.current, sxVariantFlatternStyleObject.current, sxCompoundVariantFlatternStyleObject.current, sxDescendantFlattenStyles.current, componentDescendantStyleIds, sxDescendantStyleIds, activeThemes);
      mergedBaseStyleCSSIds = a;
      mergedVariantStyleCSSIds = b;
      stateProps = c;
      mergedSXBaseStyleCSSIds = d;
      mergedSXVariantStyleCSSIds = e;
      mergedSxStateProps = f;
      mergedSxDescendantsStyle = g;
      mergedDescendantsStyle = h;
    }
    const applySxStateBaseStyleCSSIds = useRef(mergedSXBaseStyleCSSIds);
    const applySxStatePassingProps = useRef(mergedSxDescendantsStyle);
    const applySxDescendantStateStyleCSSIdsAndPropsWithKey = useRef(mergedSxStateProps);
    const [componentStatePassingProps, setComponentStatePassingProps] = useState(stateProps);
    // const [sxStatePassingProps, setSxStatePassingProps] =
    //   useState(mergedSxStateProps);

    const [applyComponentStateVariantStyleIds, setApplyComponentStateVariantStyleIds] = useState(mergedVariantStyleCSSIds);

    // const [applySxStateBaseStyleCSSIds, setApplyStateSxBaseStyleCSSIds] =
    //   useState(mergedSXBaseStyleCSSIds);

    // const [applySxStateVariantStyleCSSIds, setApplyStateSxVariantStyleCSSIds] =
    //   useState(mergedSXVariantStyleCSSIds);
    const applySxStateVariantStyleCSSIds = useRef(mergedSXVariantStyleCSSIds);

    // const [
    //   applyDescendantStateStyleCSSIdsAndPropsWithKey,
    //   setApplyDescendantStateStyleCSSIdsAndPropsWithKey,
    // ] = useState(mergedDescendantsStyle);
    const applyDescendantStateStyleCSSIdsAndPropsWithKey = useRef(mergedDescendantsStyle);
    // const [
    //   applySxDescendantStateStyleCSSIdsAndPropsWithKey,
    //   setApplySxDescendantStateStyleCSSIdsAndPropsWithKey,
    // ] = useState(mergedSxDescendantsStyle);

    // passingProps is specific to current component

    // let applyComponentInlineProps: any = componentPropsWithoutVariants;

    // const STABLEHASH_states = stableHash(states);
    // 520ms

    // Inline prop based style resolution TODO: Diagram insertion
    const defaultResolvedInlineProps = resolveInlineProps(componentStyleConfig, componentExtendedConfig, defaultThemePropsWithoutVariants, CONFIG);
    const inlineResolvedInlineProps = resolveInlineProps(componentStyleConfig, componentExtendedConfig, inlineComponentPropsWithoutVariants, CONFIG);
    const passingProps = deepMergeObjects(applyComponentPassingProps, componentStatePassingProps, sxComponentPassingProps.current, applySxStatePassingProps.current);
    let {
      sx: filteredComponentSx,
      nonVerbosedSx,
      rest: filteredComponentRemainingProps
    } = convertUtiltiyToSXFromProps(
    // Object.assign(
    //   defaultThemePropsWithoutVariants,
    inlineComponentPropsWithoutVariants, styledSystemProps, {
      ...componentStyleConfig,
      uniqueComponentId
    }, reservedKeys, plugins, ignoreKeys, (inlineComponentPropsWithoutVariants === null || inlineComponentPropsWithoutVariants === void 0 ? void 0 : inlineComponentPropsWithoutVariants.as) ?? Component, ExtendedConfig);
    let sxToBePassedIntoPlugin = {
      ...nonVerbosedSx
    };
    const mergedPassingProps = shallowMerge({
      ...defaultThemePropsWithoutVariants,
      ...passingProps
    }, applyAncestorPassingProps);
    let {
      sx: filteredPassingSx,
      nonVerbosedSx: filteredPassingNonVerbosedSx,
      rest: filteredPassingRemainingProps
    } = convertUtiltiyToSXFromProps(mergedPassingProps, styledSystemProps, {
      ...componentStyleConfig,
      uniqueComponentId
    }, reservedKeys, plugins, ignoreKeys, (mergedPassingProps === null || mergedPassingProps === void 0 ? void 0 : mergedPassingProps.as) ?? Component, ExtendedConfig);
    sxToBePassedIntoPlugin = deepMergeObjects(sxToBePassedIntoPlugin, filteredPassingNonVerbosedSx);
    let containsSX = false;
    Object.assign(applyComponentInlineProps, filteredPassingRemainingProps);
    Object.assign(applyComponentInlineProps, defaultResolvedInlineProps);
    Object.assign(applyComponentInlineProps, inlineResolvedInlineProps);
    Object.assign(applyComponentInlineProps, filteredComponentRemainingProps);
    if (Object.keys(filteredComponentSx).length > 0 || Object.keys(filteredPassingSx).length > 0) {
      containsSX = true;
    }
    let applyDescendantsStyleCSSIdsAndPropsWithKey = {};
    if (containsDescendant) {
      applyDescendantsStyleCSSIdsAndPropsWithKey = getMergeDescendantsStyleCSSIdsAndPropsWithKey(componentDescendantStyleIds, variantProps, theme, incomingComponentProps, activeThemes);
    }
    function injectAndUpdateSXProps(filteredPassingSx) {
      var _sxStyleIds$current2;
      if (Object.keys(filteredComponentSx).length > 0) {
        orderedComponentSXResolved = injectSx(filteredComponentSx, 'inline', styledContext.inlineStyleMap, ignoreKeys);
      }
      if (Object.keys(filteredPassingSx).length > 0) {
        orderedPassingSXResolved = injectSx(filteredPassingSx, 'passing', styledContext.inlineStyleMap, ignoreKeys);
      }
      const orderedSXResolved = [...orderedPassingSXResolved, ...orderedComponentSXResolved, ...BUILD_TIME_ORDERED_RESOLVED];
      // console.setStartTimeStamp('getStyleIds');
      sxStyleIds.current = getStyleIds(orderedSXResolved, componentStyleConfig);

      ///
      // Setting variants to sx property for inline variant resolution
      //@ts-ignore
      if (!sxStyleIds.current.component) {
        sxStyleIds.current.component = {};
      }
      sxStyleIds.current.component.variants = componentStyleIds.variants;
      //@ts-ignore
      sxStyleIds.current.component.compoundVariants = componentStyleIds.compoundVariants;
      // console.setStartTimeStamp('setColorModeBaseStyleIds');
      sxComponentStyleIds.current = (_sxStyleIds$current2 = sxStyleIds.current) === null || _sxStyleIds$current2 === void 0 ? void 0 : _sxStyleIds$current2.component;
      sxDescendantStyleIds.current = sxStyleIds.current.descendant;
      // 315ms
      // SX component style
      //@ts-ignore
      const {
        baseStyleCSSIds: sxBaseStyleCSSIds,
        variantStyleCSSIds: sxVariantStyleCSSIds,
        passingProps: sxPassingProps
      } = getMergedDefaultCSSIdsAndProps(
      //@ts-ignore
      sxComponentStyleIds.current, variantProps, theme, incomingComponentProps, activeThemes);
      //@ts-ignore
      // applySxStyleCSSIds.current = sxStyleCSSIds;
      //@ts-ignore
      applySxBaseStyleCSSIds.current = sxBaseStyleCSSIds;
      //@ts-ignore
      applySxVariantStyleCSSIds.current = sxVariantStyleCSSIds;
      sxComponentPassingProps.current = sxPassingProps;
    }
    if (containsSX) {
      injectAndUpdateSXProps(filteredPassingSx);
      const {
        componentBaseStyleFlatternStyleIdObject: a,
        componentVariantFlatternStyleIdObject: b,
        componentCompoundVariantFlatternStyleIdObject: c
      } = getFlattenStyleObjectFromStyleIds(sxComponentStyleIds.current);
      if (sxDescendantStyleIds.current && containsDescendant) {
        Object.keys(sxDescendantStyleIds.current).forEach(currentDescendant => {
          sxDescendantFlattenStyles.current[currentDescendant] = getFlattenStyleObjectFromStyleIds(sxDescendantStyleIds.current[currentDescendant]);
        });
      }
      sxBaseStyleFlatternStyleObject.current = a;
      sxVariantFlatternStyleObject.current = b;
      sxCompoundVariantFlatternStyleObject.current = c;

      //TODO: start: refactor for sx state + colormode + dynamic variable
      // for sx state props
      let stateColorMode = {};
      let currentStateArray = [];
      if (COLOR_MODE || states) {
        stateColorMode = {
          //@ts-ignore
          ...states,
          [COLOR_MODE]: true
        };
        currentStateArray = Object.keys(stateColorMode).filter(key => stateColorMode[key] === true);
      }

      // MUST REFACTOR: setStateAndColorModeCssIdsAndProps

      const {
        baseStyleCSSIds: mergedSXBaseStyleCSSIds,
        variantStyleCSSIds: mergedSXVariantStyleCSSIds,
        passingProps: mergedSxStateProps
      } = getMergedStateAndColorModeCSSIdsAndProps(sxComponentStyleIds.current,
      //@ts-ignore
      sxBaseStyleFlatternStyleObject.current, states, variantProps, COLOR_MODE, theme, sxVariantFlatternStyleObject.current, sxCompoundVariantFlatternStyleObject.current, currentStateArray);
      applySxStateVariantStyleCSSIds.current = mergedSXVariantStyleCSSIds;
      applySxStateBaseStyleCSSIds.current = mergedSXBaseStyleCSSIds;
      applySxStatePassingProps.current = mergedSxStateProps;
      const mergedSxDescendantsStyle = {};
      if (sxDescendantStyleIds.current) {
        Object.keys(sxDescendantStyleIds.current).forEach(key => {
          var _sxDescendantFlattenS4, _sxDescendantFlattenS5, _sxDescendantFlattenS6;
          const {
            baseStyleCSSIds: sxDescendantBaseStyleCSSIds,
            variantStyleCSSIds: sxDescendantVariantStyleCSSIds,
            passingProps: mergedPassingProps
          } = getMergedStateAndColorModeCSSIdsAndProps(
          //@ts-ignore
          sxDescendantStyleIds.current, (_sxDescendantFlattenS4 = sxDescendantFlattenStyles.current[key]) === null || _sxDescendantFlattenS4 === void 0 ? void 0 : _sxDescendantFlattenS4['componentBaseStyleFlatternStyleIdObject'], states, variantProps, COLOR_MODE, theme, (_sxDescendantFlattenS5 = sxDescendantFlattenStyles.current[key]) === null || _sxDescendantFlattenS5 === void 0 ? void 0 : _sxDescendantFlattenS5['componentVariantFlatternStyleIdObject'], (_sxDescendantFlattenS6 = sxDescendantFlattenStyles.current[key]) === null || _sxDescendantFlattenS6 === void 0 ? void 0 : _sxDescendantFlattenS6['componentCompoundVariantFlatternStyleIdObject'], currentStateArray);
          mergedSxDescendantsStyle[key] = {
            baseStyleCSSIds: sxDescendantBaseStyleCSSIds,
            variantStyleCSSIds: sxDescendantVariantStyleCSSIds,
            passingProps: mergedPassingProps
          };
        });
        applySxDescendantStateStyleCSSIdsAndPropsWithKey.current = mergedSxDescendantsStyle;
      }
      applySxStateBaseStyleCSSIds.current = mergedSXBaseStyleCSSIds;
      applySxDescendantStateStyleCSSIdsAndPropsWithKey.current = mergedSxDescendantsStyle;

      // applySxStatePassingProps.current = mergedSxStateProps;
      // mergedDescendantsStyle = _h;

      //////

      if (Object.keys(applySxStatePassingProps.current).length > 0 || Object.keys(sxComponentPassingProps.current).length > 0) {
        const passingPropsUpdated = {
          ...passingProps,
          ...sxComponentPassingProps.current,
          ...applySxStatePassingProps.current,
          ...applyAncestorPassingProps
        };
        const {
          sx: filteredPassingSxUpdated,
          nonVerbosedSx: filteredPassingNonVerbosedSxUpdated,
          rest: filteredPassingRemainingPropsUpdated
        } = convertUtiltiyToSXFromProps(passingPropsUpdated, styledSystemProps, {
          ...componentStyleConfig,
          uniqueComponentId
        }, reservedKeys, plugins, ignoreKeys, (passingPropsUpdated === null || passingPropsUpdated === void 0 ? void 0 : passingPropsUpdated.as) ?? Component, ExtendedConfig);
        sxToBePassedIntoPlugin = deepMergeObjects(sxToBePassedIntoPlugin, filteredPassingNonVerbosedSxUpdated);
        filteredPassingSx = filteredPassingSxUpdated;
        injectAndUpdateSXProps(filteredPassingSx);
        const resolvedPassingRemainingProps = resolveInlineProps(componentStyleConfig, componentExtendedConfig, filteredPassingRemainingPropsUpdated, CONFIG);

        // if (componentName === 'Switch') {
        //   console.log(
        //     // passingPropsUpdated,
        //     // resolvedPassingRemainingProps,
        //     resolvedInlineProps,
        //     // componentStyleConfig,
        //     '>>>>>>'
        //   );
        // }

        // Object.assign(applyComponentInlineProps, defaultResolvedInlineProps);
        // Object.assign(applyComponentInlineProps, filteredPassingRemainingProps);
        // Object.assign(applyComponentInlineProps, defaultInlineResolvedInlineProps);
        // Object.assign(applyComponentInlineProps, filteredComponentRemainingProps);

        Object.assign(applyComponentInlineProps, filteredPassingRemainingPropsUpdated);
        Object.assign(applyComponentInlineProps, resolvedPassingRemainingProps);
        Object.assign(applyComponentInlineProps, inlineResolvedInlineProps);
        Object.assign(applyComponentInlineProps, filteredComponentRemainingProps);
      }
    }
    if (containsDescendant) {
      //@ts-ignore
      applySxDescendantStyleCSSIdsAndPropsWithKey.current = getMergeDescendantsStyleCSSIdsAndPropsWithKey(sxDescendantStyleIds.current, variantProps, theme, incomingComponentProps, activeThemes);
    }
    const [applyComponentStateBaseStyleIds, setApplyComponentStateBaseStyleIds] = useState(mergedBaseStyleCSSIds);

    // START: Unable to optimize because of useEffect overhead and stableHash to prevent rerender
    useEffect(() => {
      onChange(colorMode => {
        // setCOLOR_MODE(colorMode);
        const {
          mergedBaseStyleCSSIds,
          mergedVariantStyleCSSIds,
          stateProps,
          mergedSXBaseStyleCSSIds,
          mergedSXVariantStyleCSSIds,
          mergedSxStateProps,
          mergedSxDescendantsStyle,
          mergedDescendantsStyle
        } = setStateAndColorModeCssIdsAndProps(colorMode, states, variantProps, theme, componentStyleIds, sxComponentStyleIds, componentBaseStyleFlatternStyleIdObject, componentVariantFlatternStyleIdObject, componentCompoundVariantFlatternStyleIdObject, componentDescendantFlattenStyles, sxBaseStyleFlatternStyleObject.current, sxVariantFlatternStyleObject, sxCompoundVariantFlatternStyleObject, sxDescendantFlattenStyles.current, componentDescendantStyleIds, sxDescendantStyleIds, activeThemes);
        setApplyComponentStateBaseStyleIds(mergedBaseStyleCSSIds);
        setApplyComponentStateVariantStyleIds(mergedVariantStyleCSSIds);
        setComponentStatePassingProps(stateProps);
        applySxStateBaseStyleCSSIds.current = mergedSXBaseStyleCSSIds;
        // setApplyStateSxBaseStyleCSSIds();
        applySxStateVariantStyleCSSIds.current = mergedSXVariantStyleCSSIds;
        applySxStatePassingProps.current = mergedSxStateProps;
        // setApplyStateSxVariantStyleCSSIds(mergedSXVariantStyleCSSIds);
        // setSxStatePassingProps(mergedSxStateProps);
        // setComponentStatePassingProps(stateProps);
        applyDescendantStateStyleCSSIdsAndPropsWithKey.current = mergedDescendantsStyle;
        applySxDescendantStateStyleCSSIdsAndPropsWithKey.current = mergedSxDescendantsStyle;
        // setApplySxDescendantStateStyleCSSIdsAndPropsWithKey(
        //   mergedSxDescendantsStyle
        // );
      });
      // remove onchage listener on unmount
      () => onChange(colorMode => {
        // setCOLOR_MODE(colorMode);
        setStateAndColorModeCssIdsAndProps(colorMode, states, variantProps, theme, componentStyleIds, sxComponentStyleIds, componentBaseStyleFlatternStyleIdObject, componentVariantFlatternStyleIdObject, componentCompoundVariantFlatternStyleIdObject, componentDescendantFlattenStyles, sxBaseStyleFlatternStyleObject.current, sxVariantFlatternStyleObject, sxCompoundVariantFlatternStyleObject, sxDescendantFlattenStyles.current, componentDescendantStyleIds, sxDescendantStyleIds, activeThemes);
      });
    }, []);
    useEffect(() => {
      if (states && isClient.current) {
        const {
          mergedBaseStyleCSSIds,
          mergedVariantStyleCSSIds,
          stateProps,
          mergedSXBaseStyleCSSIds,
          mergedSXVariantStyleCSSIds,
          mergedSxStateProps,
          mergedSxDescendantsStyle,
          mergedDescendantsStyle
        } = setStateAndColorModeCssIdsAndProps(COLOR_MODE, states, variantProps, theme, componentStyleIds, sxComponentStyleIds, componentBaseStyleFlatternStyleIdObject, componentVariantFlatternStyleIdObject, componentCompoundVariantFlatternStyleIdObject, componentDescendantFlattenStyles, sxBaseStyleFlatternStyleObject.current, sxVariantFlatternStyleObject, sxCompoundVariantFlatternStyleObject, sxDescendantFlattenStyles.current, componentDescendantStyleIds, sxDescendantStyleIds, activeThemes);
        setApplyComponentStateBaseStyleIds(mergedBaseStyleCSSIds);
        setApplyComponentStateVariantStyleIds(mergedVariantStyleCSSIds);
        setComponentStatePassingProps(stateProps);
        applySxStateBaseStyleCSSIds.current = mergedSXBaseStyleCSSIds;
        // setApplyStateSxBaseStyleCSSIds(mergedSXBaseStyleCSSIds);
        applySxStateVariantStyleCSSIds.current = mergedSXVariantStyleCSSIds;
        // setApplyStateSxVariantStyleCSSIds(mergedSXVariantStyleCSSIds);
        applySxStatePassingProps.current = mergedSxStateProps;

        // setSxStatePassingProps(mergedSxStateProps);
        // setApplyDescendantStateStyleCSSIdsAndPropsWithKey(
        //   mergedDescendantsStyle
        // );
        applyDescendantStateStyleCSSIdsAndPropsWithKey.current = mergedDescendantsStyle;
        applySxDescendantStateStyleCSSIdsAndPropsWithKey.current = mergedSxDescendantsStyle;
        // setApplySxDescendantStateStyleCSSIdsAndPropsWithKey(
        //   mergedSxDescendantsStyle
        // );
      }
      if (!isClient.current) {
        isClient.current = true;
      }

      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [states]);

    // 600ms
    const descendantCSSIds = useMemo(() => {
      if (!containsDescendant) {
        return {
          component: {},
          sx: {}
        };
      }
      const ids = (() => {
        if (applyDescendantsStyleCSSIdsAndPropsWithKey || applyDescendantStateStyleCSSIdsAndPropsWithKey.current || applySxDescendantStateStyleCSSIdsAndPropsWithKey.current || applySxDescendantStyleCSSIdsAndPropsWithKey.current || ancestorStyleContext) {
          const sxDescendantCSSIds = mergeArraysInObjects(ancestorStyleContext.sx, applySxDescendantStyleCSSIdsAndPropsWithKey.current, applySxDescendantStateStyleCSSIdsAndPropsWithKey.current);
          const componentDescendantCSSIds = mergeArraysInObjects(ancestorStyleContext.component, applyDescendantsStyleCSSIdsAndPropsWithKey, applyDescendantStateStyleCSSIdsAndPropsWithKey.current);
          return {
            component: componentDescendantCSSIds,
            sx: sxDescendantCSSIds
          };
        } else {
          return {
            component: {},
            sx: {}
          };
        }
      })();
      return ids;
    }, [stableHash(applyDescendantsStyleCSSIdsAndPropsWithKey), stableHash(applyDescendantStateStyleCSSIdsAndPropsWithKey.current), stableHash(applySxDescendantStateStyleCSSIdsAndPropsWithKey.current), ancestorStyleContext]);

    // 370ms

    // END: Unable to optimize because of useEffect overhead and stableHash to prevent rerender

    const styleCSSIds = [...applyBaseStyleCSSIds, ...applyAncestorBaseStyleCSSIds, ...applyVariantStyleCSSIds, ...applyAncestorVariantStyleCSSIds, ...applyComponentStateBaseStyleIds, ...applyComponentStateVariantStyleIds, ...applySxAncestorBaseStyleCSSIds, ...applySxAncestorVariantStyleCSSIds,
    // ...applySxAncestorBaseStyleCSSIds,
    ...applySxVariantStyleCSSIds.current, ...applySxStateVariantStyleCSSIds.current, ...applySxBaseStyleCSSIds.current, ...applySxStateBaseStyleCSSIds.current];

    // Object.assign(resolvedInlineProps, applyComponentInlineProps);

    const componentConfig = {
      componentName: componentStyleConfig === null || componentStyleConfig === void 0 ? void 0 : componentStyleConfig.componentName,
      colorMode: styledContext.colorMode,
      ...variantProps,
      states
    };

    //@ts-ignore
    if (applyComponentInlineProps !== null && applyComponentInlineProps !== void 0 && applyComponentInlineProps.as || passingProps !== null && passingProps !== void 0 && (_passingProps$as = passingProps.as) !== null && _passingProps$as !== void 0 && _passingProps$as.displayName) {
      var _applyComponentInline, _passingProps$as2, _applyComponentInline2, _passingProps$as3;
      componentConfig.componentName =
      //@ts-ignore
      (applyComponentInlineProps === null || applyComponentInlineProps === void 0 || (_applyComponentInline = applyComponentInlineProps.as) === null || _applyComponentInline === void 0 ? void 0 : _applyComponentInline.displayName) ?? (passingProps === null || passingProps === void 0 || (_passingProps$as2 = passingProps.as) === null || _passingProps$as2 === void 0 ? void 0 : _passingProps$as2.displayName);
      componentConfig.as =
      //@ts-ignore
      (applyComponentInlineProps === null || applyComponentInlineProps === void 0 || (_applyComponentInline2 = applyComponentInlineProps.as) === null || _applyComponentInline2 === void 0 ? void 0 : _applyComponentInline2.displayName) ?? (passingProps === null || passingProps === void 0 || (_passingProps$as3 = passingProps.as) === null || _passingProps$as3 === void 0 ? void 0 : _passingProps$as3.displayName);
    }
    const resolvedStyleProps = generateStylePropsFromCSSIds(applyComponentInlineProps, styleCSSIds, CONFIG, activeThemes, componentConfig);

    // let AsComp: any = React.useRef(
    //   resolvedStyleProps.as || (passingProps.as as any) || undefined
    // ).current;

    let AsComp = React.useMemo(() => {
      return resolvedStyleProps.as || passingProps.as || undefined;
    }, [resolvedStyleProps.as]);
    let resolvedStyleMemo = [passingProps === null || passingProps === void 0 ? void 0 : passingProps.style, ...(resolvedStyleProps === null || resolvedStyleProps === void 0 ? void 0 : resolvedStyleProps.style)];
    if (Platform.OS === 'web') {
      resolvedStyleMemo = StyleSheet.flatten(resolvedStyleMemo);
    }
    resolvedStyleProps === null || resolvedStyleProps === void 0 || delete resolvedStyleProps.as;

    // }

    const ComponentWithPlugin = React.useMemo(() => {
      if (plugins.length > 0) {
        //@ts-ignore
        if (AsComp && !(Component !== null && Component !== void 0 && Component.isStyledComponent)) {
          for (const pluginName in plugins) {
            var _plugins$pluginName5;
            // @ts-ignore
            if ((_plugins$pluginName5 = plugins[pluginName]) !== null && _plugins$pluginName5 !== void 0 && _plugins$pluginName5.componentMiddleWare) {
              var _plugins$pluginName6, _AsComp;
              // @ts-ignore
              AsComp = (_plugins$pluginName6 = plugins[pluginName]) === null || _plugins$pluginName6 === void 0 ? void 0 : _plugins$pluginName6.componentMiddleWare({
                Component: AsComp,
                theme,
                componentStyleConfig: {
                  ...componentStyleConfig,
                  uniqueComponentId
                },
                ExtendedConfig,
                styleCSSIds,
                GluestackStyleSheet
              });
              //@ts-ignore
              pluginData = {
                ...pluginData,
                ...((_AsComp = AsComp) === null || _AsComp === void 0 ? void 0 : _AsComp.styled)
              };
            }
          }
        } else {
          for (const pluginName in plugins) {
            var _plugins$pluginName7;
            // @ts-ignore
            if ((_plugins$pluginName7 = plugins[pluginName]) !== null && _plugins$pluginName7 !== void 0 && _plugins$pluginName7.componentMiddleWare) {
              var _plugins$pluginName8, _GluestackComponent$c;
              // @ts-ignore
              GluestackComponent.current = (_plugins$pluginName8 = plugins[pluginName]) === null || _plugins$pluginName8 === void 0 ? void 0 : _plugins$pluginName8.componentMiddleWare({
                Component: GluestackComponent.current,
                theme,
                componentStyleConfig: {
                  ...componentStyleConfig,
                  uniqueComponentId
                },
                ExtendedConfig,
                styleCSSIds,
                GluestackStyleSheet
              });
              pluginData = {
                ...pluginData,
                //@ts-ignore
                ...(GluestackComponent === null || GluestackComponent === void 0 || (_GluestackComponent$c = GluestackComponent.current) === null || _GluestackComponent$c === void 0 ? void 0 : _GluestackComponent$c.styled)
              };
            }
          }
        }
      }
      return {
        Component: GluestackComponent.current,
        AsComp: AsComp
      };
    }, [AsComp]);
    let component;
    const propsToBePassedInToPlugin = (plugins === null || plugins === void 0 ? void 0 : plugins.length) > 0 ? {
      ...variantProps,
      states: states,
      sx: sxToBePassedIntoPlugin
    } : {};
    if (AsComp) {
      var _ComponentWithPlugin$;
      //@ts-ignore
      if (ComponentWithPlugin !== null && ComponentWithPlugin !== void 0 && (_ComponentWithPlugin$ = ComponentWithPlugin.Component) !== null && _ComponentWithPlugin$ !== void 0 && _ComponentWithPlugin$.isStyledComponent) {
        component = /*#__PURE__*/React.createElement(ComponentWithPlugin.Component, _extends({}, resolvedStyleProps, variantProps, propsToBePassedInToPlugin, {
          states: states,
          style: resolvedStyleMemo,
          as: AsComp,
          ref: ref
        }));
      } else {
        component = /*#__PURE__*/React.createElement(ComponentWithPlugin.AsComp, _extends({}, resolvedStyleProps, {
          style: resolvedStyleMemo,
          ref: ref
        }));
      }
    } else {
      var _ComponentWithPlugin$2;
      //@ts-ignores
      component = ComponentWithPlugin !== null && ComponentWithPlugin !== void 0 && (_ComponentWithPlugin$2 = ComponentWithPlugin.Component) !== null && _ComponentWithPlugin$2 !== void 0 && _ComponentWithPlugin$2.isStyledComponent ? /*#__PURE__*/React.createElement(ComponentWithPlugin.Component, _extends({}, resolvedStyleProps, propsToBePassedInToPlugin, variantProps, {
        states: states,
        style: resolvedStyleMemo,
        ref: ref
      })) : /*#__PURE__*/React.createElement(ComponentWithPlugin.Component, _extends({}, resolvedStyleProps, propsToBePassedInToPlugin, {
        style: resolvedStyleMemo,
        ref: ref
      }));
    }
    if (containsDescendant) {
      return /*#__PURE__*/React.createElement(AncestorStyleContext.Provider, {
        value: descendantCSSIds
      }, component);
    }
    return component;
  };
  const StyledComp = /*#__PURE__*/React.forwardRef(StyledComponent);

  //@ts-ignore
  StyledComp.getStyledData = () => pluginData;
  const displayName = componentStyleConfig !== null && componentStyleConfig !== void 0 && componentStyleConfig.componentName ? componentStyleConfig === null || componentStyleConfig === void 0 ? void 0 : componentStyleConfig.componentName : Component === null || Component === void 0 ? void 0 : Component.displayName;
  StyledComp.displayName = displayName ? 'Styled' + displayName : 'StyledComponent';

  //@ts-ignore
  StyledComp.isStyledComponent = true;
  return StyledComp;
}
export function styled(Component, theme = {}, componentStyleConfig, ExtendedConfig, BUILD_TIME_PARAMS) {
  const nonVerbosedTheme = theme;
  // const DEBUG_TAG = componentStyleConfig?.DEBUG;
  // const DEBUG =
  //   process.env.NODE_ENV === 'development' && DEBUG_TAG ? false : false;

  // const componentName = componentStyleConfig?.componentName;
  // const componentExtendedTheme = extendedThemeConfig?.theme;
  // const componentExtended_build_time_params =
  //   extendedThemeConfig?.BUILD_TIME_PARAMS;
  // let mergedBuildTimeParams: any;

  if (BUILD_TIME_PARAMS) {
    // mergedBuildTimeParams = Array(
    //   { ...BUILD_TIME_PARAMS },
    //   { ...componentExtended_build_time_params }
    // );
  }

  // let styledObj = { ...theme };
  // if (componentExtendedTheme) {
  //   styledObj = deepMerge({ ...theme }, { ...componentExtendedTheme });
  // }

  // // move inside stylehash created
  // let plugins = [...getInstalledPlugins()];

  // if (ExtendedConfig?.plugins) {
  //   // @ts-ignore
  //   plugins = [...plugins, ...ExtendedConfig?.plugins];
  // }

  // for (const pluginName in plugins) {
  //   // @ts-ignore
  //   [styledObj, , , Component] = plugins[pluginName]?.inputMiddleWare<P>(
  //     styledObj,
  //     true,
  //     true,
  //     Component
  //   );
  // }

  // theme = styledObj;

  // move inside stylehash created

  const sxConvertedObject = convertStyledToStyledVerbosed(theme);
  let StyledComponent = verboseStyled(Component, sxConvertedObject, componentStyleConfig, ExtendedConfig, BUILD_TIME_PARAMS, nonVerbosedTheme);

  // @ts-ignore
  StyledComponent.isAnimatedComponent = Component === null || Component === void 0 ? void 0 : Component.isAnimatedComponent;

  // move before returning component from verboseStyled

  // @ts-ignore
  // plugins?.reverse();
  // for (const pluginName in plugins) {
  //   // @ts-ignore
  //   if (plugins[pluginName]?.componentMiddleWare) {
  //     // @ts-ignore
  //     StyledComponent = plugins[pluginName]?.componentMiddleWare({
  //       Component: StyledComponent,
  //       theme,
  //       componentStyleConfig,
  //       ExtendedConfig,
  //     });
  //   }
  // }
  // move before returning component from verboseStyled

  // for (const pluginName in plugins) {
  //   const compWrapper =
  //     // @ts-ignore
  //     typeof plugins[pluginName].wrapperComponentMiddleWare === 'function'
  //       ? // @ts-ignore
  //         plugins[pluginName].wrapperComponentMiddleWare()
  //       : null;

  //   if (compWrapper) {
  //     for (const key of Object.keys(compWrapper)) {
  //       // @ts-ignore
  //       StyledComponent[key] = compWrapper[key];
  //     }
  //   }
  // }

  return StyledComponent;
}
//# sourceMappingURL=styled.js.map