import { StyledValueToCSSObject, themeStyledValueToCSSObject } from '../resolver/StyledValueToCSSObject';
import { getCSSIdAndRuleset } from '../updateCSSStyleInOrderedResolved.web';
import { convertFromUnicodeString, deepMerge, resolveTokensFromConfig } from '../utils';
import { inject } from '../utils/css-injector';
const cssVariableRegex = /var\(--([^)]+)\)/;
const negativeCSSVariableRegex = /^calc\(var\(.+\) \* -1\)$/;
function getTokenValueFromTokenPath(tokenPath, tokens) {
  const tokenPathArray = tokenPath.split('-');
  let tokenValue = tokens;
  tokenPathArray.forEach(tokenPathKey => {
    var _tokenValue;
    tokenValue = (_tokenValue = tokenValue) === null || _tokenValue === void 0 ? void 0 : _tokenValue[tokenPathKey];
  });
  return tokenValue;
}
function extractVariable(input) {
  if (typeof input !== 'string') return null;
  const match = input.match(cssVariableRegex);
  return match ? match[1] : null;
}
function getNativeValuesFromCSSVariables(styleObject, CONFIG) {
  const resolvedNativeValues = {};
  Object.keys(styleObject).forEach(key => {
    const hyphenatedTokenPath = convertFromUnicodeString(extractVariable(styleObject[key]));
    const isNegativeToken = negativeCSSVariableRegex.test(styleObject[key]);
    if (!hyphenatedTokenPath) {
      resolvedNativeValues[key] = styleObject[key];
    } else {
      let val = getTokenValueFromTokenPath(hyphenatedTokenPath, CONFIG);
      if (isNegativeToken) {
        if (typeof val === 'number') {
          val = -val;
        } else if (typeof val === 'string') {
          val = `-${val}`;
        }
      }
      resolvedNativeValues[key] = val;
    }
  });
  return resolvedNativeValues;
}
export class StyleInjector {
  #globalStyleMap;
  #toBeInjectedIdsArray;
  #idCounter;
  constructor() {
    this.#globalStyleMap = new Map();
    this.#toBeInjectedIdsArray = [];
    this.#idCounter = 0;
  }
  declare(orderedSXResolved, _wrapperElementId, _styleTagId = 'css-injected-boot-time', extendedConfig) {
    const styleIds = [];
    orderedSXResolved.forEach(styledResolved => {
      var _styledResolved$meta;
      if (styledResolved !== null && styledResolved !== void 0 && (_styledResolved$meta = styledResolved.meta) !== null && _styledResolved$meta !== void 0 && _styledResolved$meta.cssId) {
        this.#globalStyleMap.set(styledResolved.meta.cssId, {
          ...styledResolved,
          type: _wrapperElementId,
          componentHash: _styleTagId,
          id: this.#idCounter,
          extendedConfig
        });
        this.#idCounter++;
        styleIds.push(styledResolved.meta.cssId);
      }
    });
    return styleIds;
  }
  resolve(cssIds = [], CONFIG, ExtendedConfig, resolve = true, declarationType = 'boot', ignoreKeys = new Set()) {
    let componentExtendedConfig = CONFIG;
    if (ExtendedConfig) {
      componentExtendedConfig = deepMerge(CONFIG, ExtendedConfig);
    }
    const toBeInjected = {};
    cssIds === null || cssIds === void 0 || cssIds.forEach(cssId => {
      if (this.#globalStyleMap.get(cssId)) {
        var _styledResolved$meta2;
        const styledResolved = this.#globalStyleMap.get(cssId);
        const theme = styledResolved === null || styledResolved === void 0 ? void 0 : styledResolved.original;
        if (resolve) {
          this.resolveComponentTheme(styledResolved, theme, componentExtendedConfig, styledResolved.componentHash, CONFIG, declarationType, ignoreKeys);
        }
        const type = styledResolved === null || styledResolved === void 0 ? void 0 : styledResolved.type;
        const styleTag = styledResolved === null || styledResolved === void 0 ? void 0 : styledResolved.componentHash;
        const cssRuleset = styledResolved === null || styledResolved === void 0 || (_styledResolved$meta2 = styledResolved.meta) === null || _styledResolved$meta2 === void 0 ? void 0 : _styledResolved$meta2.cssRuleset;
        if (!toBeInjected[type]) {
          toBeInjected[type] = new Map();
        }
        const cummialtiveCssRuleset = toBeInjected[type].get(styleTag);
        if (!cummialtiveCssRuleset) {
          toBeInjected[type].set(styleTag, {
            id: styledResolved.id,
            cssRuleset: cssRuleset ?? ''
          });
        } else {
          toBeInjected[type].set(styleTag, {
            id: cummialtiveCssRuleset === null || cummialtiveCssRuleset === void 0 ? void 0 : cummialtiveCssRuleset.id,
            cssRuleset: (cummialtiveCssRuleset === null || cummialtiveCssRuleset === void 0 ? void 0 : cummialtiveCssRuleset.cssRuleset) + cssRuleset
          });
        }
        const resolvedNativeValue = getNativeValuesFromCSSVariables(styledResolved === null || styledResolved === void 0 ? void 0 : styledResolved.resolved, CONFIG === null || CONFIG === void 0 ? void 0 : CONFIG.tokens);
        const resolvedThemeNativeValue = {};
        Object.keys(styledResolved === null || styledResolved === void 0 ? void 0 : styledResolved.themeResolved).forEach(key => {
          var _CONFIG$themes;
          const currentThemeStyleObj = styledResolved === null || styledResolved === void 0 ? void 0 : styledResolved.themeResolved[key];
          const resolvedCurrentThemeNativeValue = getNativeValuesFromCSSVariables(currentThemeStyleObj, CONFIG === null || CONFIG === void 0 || (_CONFIG$themes = CONFIG.themes) === null || _CONFIG$themes === void 0 || (_CONFIG$themes = _CONFIG$themes.tokens) === null || _CONFIG$themes === void 0 ? void 0 : _CONFIG$themes[key]);
          resolvedThemeNativeValue[key] = resolvedCurrentThemeNativeValue;
        });
        if (styledResolved) {
          this.#globalStyleMap.set(styledResolved.meta.cssId, {
            ...styledResolved,
            resolved: resolvedNativeValue,
            themeResolved: resolvedThemeNativeValue
          });
        }
      }
    });
    return toBeInjected;
  }
  update(orderResolvedStyleMap) {
    const toBeInjected = {};
    orderResolvedStyleMap.forEach(styledResolved => {
      var _styledResolved$meta3;
      this.#globalStyleMap.set(styledResolved.meta.cssId, styledResolved);
      this.#idCounter++;
      this.#toBeInjectedIdsArray.push(styledResolved.meta.cssId);
      const type = styledResolved === null || styledResolved === void 0 ? void 0 : styledResolved.type;
      const styleTag = styledResolved === null || styledResolved === void 0 ? void 0 : styledResolved.componentHash;
      const cssRuleset = styledResolved === null || styledResolved === void 0 || (_styledResolved$meta3 = styledResolved.meta) === null || _styledResolved$meta3 === void 0 ? void 0 : _styledResolved$meta3.cssRuleset;
      if (!toBeInjected[type]) {
        toBeInjected[type] = new Map();
      }
      const cummialtiveCssRuleset = toBeInjected[type].get(styleTag);
      if (!cummialtiveCssRuleset) {
        toBeInjected[type].set(styleTag, {
          id: styledResolved.id,
          cssRuleset: cssRuleset ?? ''
        });
      } else {
        toBeInjected[type].set(styleTag, {
          id: cummialtiveCssRuleset === null || cummialtiveCssRuleset === void 0 ? void 0 : cummialtiveCssRuleset.id,
          cssRuleset: (cummialtiveCssRuleset === null || cummialtiveCssRuleset === void 0 ? void 0 : cummialtiveCssRuleset.cssRuleset) + cssRuleset
        });
      }
    });
    return toBeInjected;
  }
  inject(toBeInjected = {}, inlineStyleMap) {
    Object.keys(toBeInjected).forEach(type => {
      toBeInjected[type].forEach(({
        id,
        cssRuleset
      }, styleTag) => {
        this.injectStyles(cssRuleset, type, styleTag, inlineStyleMap, id);
      });
    });
  }
  resolveComponentTheme(componentTheme, theme, componentExtendedConfig, componentHashKey, CONFIG, declarationType = 'boot', ignoreKeys = new Set()) {
    const prefixClassName = declarationType === 'inline' ? 'gs' : '';
    componentTheme.resolved = StyledValueToCSSObject(theme, componentExtendedConfig, ignoreKeys);
    componentTheme.themeResolved = themeStyledValueToCSSObject(theme, componentExtendedConfig, ignoreKeys);

    // addThemeConditionInMeta(componentTheme, CONFIG);
    // delete componentTheme.meta.cssRuleset;

    if (componentTheme.meta && componentTheme.meta.queryCondition) {
      var _resolveTokensFromCon;
      const queryCondition = (_resolveTokensFromCon = resolveTokensFromConfig(CONFIG, {
        condition: componentTheme.meta.queryCondition
      }, true)) === null || _resolveTokensFromCon === void 0 ? void 0 : _resolveTokensFromCon.condition;
      componentTheme.meta.queryCondition = queryCondition;
    }
    const cssData = getCSSIdAndRuleset(componentTheme, componentHashKey, prefixClassName);
    componentTheme.meta.cssRuleset = cssData.rules.style;
  }
  getStyleMap() {
    return this.#globalStyleMap;
  }
  injectStyles(cssRuleset, _wrapperType, _styleTagId, inlineStyleMap, id) {
    if (cssRuleset) {
      inject(`@media screen {${cssRuleset}}`, _wrapperType, _styleTagId, inlineStyleMap, id);
    }
  }
}
const stylesheet = new StyleInjector();
export const GluestackStyleSheet = stylesheet;
//# sourceMappingURL=index.js.map