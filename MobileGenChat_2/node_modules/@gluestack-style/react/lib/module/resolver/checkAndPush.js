import { deepMergeArray } from '../utils';
export function checkAndPush(item, ret, keyToCheck) {
  var _item$meta;
  function getIndexes(array, str) {
    return array.map((item, index) => item === str ? index : -1).filter(i => i !== -1);
  }
  function createNestedObject(arr) {
    let obj = {};
    arr.reduce((acc, curr) => {
      return acc[curr] = {};
    }, obj);
    return obj;
  }
  function setNestedObjectValue(obj, keyPath, value) {
    // If the key path is empty, return the value
    if (keyPath.length === 0) return value;

    // Otherwise, set the value at the current key path and recurse
    const key = keyPath[0];
    obj[key] = obj[key] || {};
    obj[key] = setNestedObjectValue(obj[key], keyPath.slice(1), value);
    return obj;
  }
  // keyToCheck = "baseStyle" | "variants" | "sizes"
  if ((_item$meta = item.meta) !== null && _item$meta !== void 0 && _item$meta.path.includes(keyToCheck)) {
    // if (!item.meta.path.includes('state')) {
    //   if (!ret.ids) {
    //     ret.ids = [];
    //   }
    //   ret.ids.push(item.meta.cssId);
    //   ret.props = item?.meta?.props;
    // } else
    if (!item.meta.path.includes('state') && !item.meta.path.includes('colorMode') && !item.meta.path.includes('theme')) {
      var _item$meta2;
      if (!ret.ids) {
        ret.ids = [];
      }
      ret.ids.push(item.meta.cssId);
      ret.props = item === null || item === void 0 || (_item$meta2 = item.meta) === null || _item$meta2 === void 0 ? void 0 : _item$meta2.props;

      // ret.default.push(item.meta.cssId);
    } else if (item.meta.path.includes('state') || item.meta.path.includes('colorMode') || item.meta.path.includes('theme')) {
      var _item$meta3;
      const allStates = getIndexes(item.meta.path, 'state');
      const allColorModes = getIndexes(item.meta.path, 'colorMode');
      const allThemes = getIndexes(item.meta.path, 'theme');

      // const allStatesAndColorMode = [...allStates, ...allColorModes];

      const mergeAllStateKey = [];
      allStates.forEach(statePath => {
        const state = item.meta.path[statePath + 1];
        mergeAllStateKey.push('state');
        mergeAllStateKey.push(state);
      });
      allColorModes.forEach(colorModePath => {
        const colorMode = item.meta.path[colorModePath + 1];
        mergeAllStateKey.push('colorMode');
        mergeAllStateKey.push(colorMode);
      });
      allThemes.forEach(themePath => {
        const theme = item.meta.path[themePath + 1];
        mergeAllStateKey.push('theme');
        mergeAllStateKey.push(theme);
      });
      const stateObject = createNestedObject(mergeAllStateKey);
      setNestedObjectValue(stateObject, mergeAllStateKey, {
        ids: [item.meta.cssId],
        props: item === null || item === void 0 || (_item$meta3 = item.meta) === null || _item$meta3 === void 0 ? void 0 : _item$meta3.props
      });
      deepMergeArray(ret, stateObject);
    }
  }
}
//# sourceMappingURL=checkAndPush.js.map