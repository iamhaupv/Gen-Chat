"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.injectGlobalCss = exports.injectCss = exports.flush = void 0;
var _react = _interopRequireDefault(require("react"));
var _reactNative = require("react-native");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const toBeFlushedStyles = {};
const order = ['global', 'forwarded-base', 'forwarded-descendant-base', 'forwarded-variant', 'forwarded-descendant-variant',
// base
'boot-base', 'extended-base', 'composed-base', 'boot-base-state', 'extended-base-state', 'composed-base-state',
// descendant-base
'boot-descendant-base', 'extended-descendant-base', 'composed-descendant-base', 'boot-descendant-base-state', 'extended-descendant-base-state', 'composed-descendant-base-state',
// variant
'boot-variant', 'extended-variant', 'composed-variant', 'boot-variant-state', 'extended-variant-state', 'composed-variant-state',
// descendant-variant
'boot-descendant-variant', 'extended-descendant-variant', 'composed-descendant-variant', 'boot-descendant-variant-state', 'extended-descendant-variant-state', 'composed-descendant-variant-state',
// inline
'inline-descendant-base', 'passing-base', 'inline-variant', 'inline-base', 'inline-base-state'];
const WRAPPER_BLOCK_PREFIX = 'gs-injected';
if (typeof window !== 'undefined') {
  //TODO: remvoe platform dependency
  // Test on all the platforms
  if (_reactNative.Platform.OS === 'web') {
    // create a wrapper div for all injected styles

    // append this wrapper div in
    let wrapperBlockDiv = document.getElementById(WRAPPER_BLOCK_PREFIX);
    if (!wrapperBlockDiv) {
      const createdWrapperBlockDiv = document.createElement('div');
      createdWrapperBlockDiv.id = WRAPPER_BLOCK_PREFIX;
      wrapperBlockDiv = document.head.appendChild(createdWrapperBlockDiv);
    }

    // document.head

    order.forEach(orderKey => {
      let wrapperElement = document.getElementById(`${WRAPPER_BLOCK_PREFIX}-${orderKey}`);
      if (!wrapperElement) {
        var _wrapperBlockDiv;
        wrapperElement = document.createElement('div');
        wrapperElement.id = `${WRAPPER_BLOCK_PREFIX}-${orderKey}`;
        (_wrapperBlockDiv = wrapperBlockDiv) === null || _wrapperBlockDiv === void 0 || _wrapperBlockDiv.appendChild(wrapperElement);
      }
    });
  }
}
const createStyle = (styleTagId, css) => {
  //
  let style = document.createElement('style');
  style.id = styleTagId;
  style.appendChild(document.createTextNode(''));
  style.innerHTML = css;
  return style;
};
const injectCss = (css, wrapperType, styleTagId, inlineStyleMap, id) => {
  if (!toBeFlushedStyles[wrapperType]) {
    toBeFlushedStyles[wrapperType] = {};
  }
  if (toBeFlushedStyles[wrapperType][styleTagId]) {
    // toBeFlushedStyles[wrapperType][styleTagId].push(css);
  } else {
    toBeFlushedStyles[wrapperType][styleTagId] = [css];
  }
  if (typeof window !== 'undefined') {
    let wrapperElement = document.querySelector('#' + `${WRAPPER_BLOCK_PREFIX}-${wrapperType}`);
    if (wrapperElement) {
      let style = wrapperElement.querySelector(`[id='${styleTagId}']`);
      if (!style) {
        style = createStyle(styleTagId, css);
        if (inlineStyleMap && !(inlineStyleMap !== null && inlineStyleMap !== void 0 && inlineStyleMap.initialStyleInjected)) {
          const styleMapId = `${WRAPPER_BLOCK_PREFIX}-${wrapperType}`;
          const inlineMapStyles = inlineStyleMap[styleMapId];
          if (inlineMapStyles) {
            inlineMapStyles[id] = style;
          } else {
            inlineStyleMap[styleMapId] = [];
            inlineStyleMap[styleMapId][id] = style;
          }
          // console.log('hello here >>>> there');
        } else {
          // console.log('hello here >>>>');
          wrapperElement.appendChild(style);
        }
      }
    }
  }

  // if (modifiedStylesheet && modifiedStylesheet.insertRule) {
  //   modifiedStylesheet.insertRule(css);
  // }
};
exports.injectCss = injectCss;
const injectGlobalCss = (css, styleTagID = 'css-injected-global') => {
  injectCss(css, 'global', styleTagID);
};
exports.injectGlobalCss = injectGlobalCss;
const flush = () => {
  let toBeFlushedStylesGlobal = [];
  order.forEach(orderKey => {
    const styleChildren = [];
    if (toBeFlushedStyles[orderKey]) {
      Object.keys(toBeFlushedStyles[orderKey]).forEach(styleTagId => {
        let rules = toBeFlushedStyles[orderKey][styleTagId];
        styleChildren.push( /*#__PURE__*/_react.default.createElement('style', {
          id: styleTagId,
          key: styleTagId,
          dangerouslySetInnerHTML: {
            __html: rules.join('\n')
          }
        }));
      });
    }
    toBeFlushedStylesGlobal.push( /*#__PURE__*/_react.default.createElement('div', {
      id: `${WRAPPER_BLOCK_PREFIX}-${orderKey}`,
      key: `${WRAPPER_BLOCK_PREFIX}-${orderKey}`
    }, styleChildren));
  });
  const toBeFlushedStylesWrrapperDiv = /*#__PURE__*/_react.default.createElement('div', {
    id: WRAPPER_BLOCK_PREFIX,
    children: toBeFlushedStylesGlobal
  });

  // return an array of elements

  return [toBeFlushedStylesWrrapperDiv];
};
exports.flush = flush;
//# sourceMappingURL=inject.web.js.map