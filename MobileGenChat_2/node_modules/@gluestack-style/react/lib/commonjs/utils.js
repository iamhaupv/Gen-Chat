"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BASE_FONT_SIZE = void 0;
exports.addThemeConditionInMeta = addThemeConditionInMeta;
exports.convertAbsoluteToRem = exports.convertAbsoluteToPx = void 0;
exports.convertFromUnicodeString = convertFromUnicodeString;
exports.convertRemToAbsolute = void 0;
exports.convertToUnicodeString = convertToUnicodeString;
exports.convertTokensToCssVariables = convertTokensToCssVariables;
exports.deepMergeArray = exports.deepMerge = void 0;
exports.deepMergeObjects = deepMergeObjects;
exports.extractWidthValues = extractWidthValues;
exports.generateMergedThemeTokens = generateMergedThemeTokens;
exports.getObjectProperty = exports.getCssVariableValue = void 0;
exports.getResolvedTokenValueFromConfig = getResolvedTokenValueFromConfig;
exports.platformSpecificSpaceUnits = exports.getTokenFromConfig = void 0;
exports.resolveAliasesFromConfig = resolveAliasesFromConfig;
exports.resolvePlatformTheme = resolvePlatformTheme;
exports.resolveStringToken = resolveStringToken;
exports.resolveTokensFromConfig = resolveTokensFromConfig;
exports.resolvedTokenization = resolvedTokenization;
exports.shallowMerge = exports.setObjectKeyValue = void 0;
var _common = require("./utils/cssify/utils/common");
const propsNotToConvertToCSSVariables = ['shadowColor', 'textShadowColor'];
function generateMergedThemeTokens(CONFIG) {
  const mergedTokens = CONFIG;
  const tokens = (0, _common.deepClone)((CONFIG === null || CONFIG === void 0 ? void 0 : CONFIG.tokens) ?? {});
  const themeTokens = {};
  if (CONFIG !== null && CONFIG !== void 0 && CONFIG.themes) {
    Object.keys(CONFIG.themes).forEach(key => {
      // tokens is a reserved key to merge theme tokens
      if (key !== 'tokens') {
        themeTokens[key] = deepMerge(tokens, CONFIG.themes[key]);
      }
    });
    if (themeTokens) {
      mergedTokens.themes.tokens = {};
      Object.assign(mergedTokens.themes.tokens, themeTokens);
    }
  }
  return mergedTokens;
}
function convertToUnicodeString(inputString) {
  let result = '';
  if (!inputString) {
    return result;
  }
  for (let i = 0; i < inputString.length; i++) {
    const currentChar = inputString.charAt(i);

    // Check if the character is a special character (excluding "-" and "_")
    if (/[^a-zA-Z0-9\-_]/.test(currentChar)) {
      // Convert the special character to its Unicode representation
      const unicodeValue = currentChar.charCodeAt(0).toString(16);
      result += `\\u${'0000'.slice(unicodeValue.length)}${unicodeValue}`;
    } else {
      // Keep non-special characters, "-", and "_" as they are
      result += currentChar;
    }
  }
  return result;
}
function convertFromUnicodeString(inputString) {
  let result = '';
  if (!inputString) {
    return result;
  }

  // Use a regular expression to match Unicode sequences (e.g., \uXXXX)
  const unicodeRegex = /\\u[0-9a-fA-F]{4}/g;

  // Replace each Unicode sequence with its corresponding character
  result = inputString.replace(unicodeRegex, match => {
    // Extract the Unicode value from the matched sequence
    const unicodeValue = parseInt(match.substring(2), 16);
    // Convert the Unicode value to the corresponding character
    return String.fromCharCode(unicodeValue);
  });
  return result;
}
function convertTokensToCssVariables(currentConfig) {
  function objectToCssVariables(obj = {}, prefix = '') {
    return Object.keys(obj).reduce((acc, key) => {
      const variableName = `--${prefix}${key}`;
      const variableValue = obj[key];
      if (typeof variableValue === 'object') {
        // Recursively process nested objects
        acc += objectToCssVariables(variableValue, `${prefix}${key}-`);
      } else {
        acc += `${convertToUnicodeString(variableName)}: ${variableValue};\n`;
      }
      return acc;
    }, '');
  }
  const tokens = currentConfig === null || currentConfig === void 0 ? void 0 : currentConfig.tokens;
  const cssVariables = objectToCssVariables(tokens);
  let content = `:root {\n${cssVariables}}`;
  if (currentConfig.themes) {
    Object.keys(currentConfig.themes).forEach(key => {
      const theme = currentConfig.themes[key];
      const cssVariables = objectToCssVariables(theme);
      content += `\n\n[data-theme-id=${key}] {\n${cssVariables}}`;
    });
  }
  return content;

  // const cssVariablesBlock = `
  // :root {
  //   --colors-red500: blue;
  // }
  //   `;

  // return cssVariablesBlock;
}

// --------------------------------- 3. Preparing style map for Css Injection based on precedence --------------------------------------

const setObjectKeyValue = (obj, keys, value) => {
  let current = obj;
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (i === keys.length - 1) {
      // we've reached the desired key, so update its value
      current[key] = value;
    } else {
      // we're still traversing the object, so create the key if it doesn't exist
      if (!current[key]) {
        current[key] = {};
      }
      current = current[key];
    }
  }
  return obj;
};
exports.setObjectKeyValue = setObjectKeyValue;
const getObjectProperty = (object, keyPath) => {
  if (!Array.isArray(keyPath)) {
    keyPath = [keyPath];
  }
  return keyPath.reduce((baseObj, key) => baseObj && baseObj[key], object);
};
exports.getObjectProperty = getObjectProperty;
const getCssVariableValue = (_object, _keyPath) => {
  // console.log(keyPath, 'key path here');
};
exports.getCssVariableValue = getCssVariableValue;
function resolveAliasesFromConfig(config, props, ignoreKeys = new Set()) {
  const aliasResolvedProps = {};
  Object.keys(props).map(key => {
    if (!ignoreKeys.has(key)) {
      var _config$aliases;
      if (config !== null && config !== void 0 && (_config$aliases = config.aliases) !== null && _config$aliases !== void 0 && _config$aliases[key]) {
        var _config$aliases2;
        aliasResolvedProps[(_config$aliases2 = config.aliases) === null || _config$aliases2 === void 0 ? void 0 : _config$aliases2[key]] = props[key];
      } else {
        aliasResolvedProps[key] = props[key];
      }
    }
  });
  return aliasResolvedProps;
}

// function checkKey(obj: any, key: any) {
//   return obj && obj.hasOwnProperty(key);
// }
function isNumeric(str) {
  return typeof str === 'number' ? true : false;
  // return /^[-+]?[0-9]*\.?[0-9]+$/.test(str);
}
function resolveStringToken(stringValue, config, tokenScaleMap, propName, scale, useResolvedValue = false, deleteIfTokenNotExist = false) {
  // console.setStartTimeStamp('resolveStringToken');
  let typeofResult = 'string';
  const token_scale = scale ?? tokenScaleMap[propName];
  const splitTokenBySpace = stringValue.split(' ');
  const result = splitTokenBySpace.map(currentToken => {
    let splitCurrentToken = currentToken.split('$');
    if (currentToken.startsWith('$')) {
      splitCurrentToken = splitCurrentToken.slice(1);
    }
    if (splitCurrentToken.length > 1) {
      //

      // console.log('>>>>> 22');
      const tokenValue = getObjectProperty(config.tokens, splitCurrentToken);

      // console.log(tokenValue, '.>>>>', currentToken);
      // const tokenValue = getCssVariableValue(config.tokens, splitCurrentToken);
      typeofResult = typeof tokenValue;
      return tokenValue;
    } else {
      if (tokenScaleMap[propName]) {
        var _config$tokens$token_;
        let modifiedTokenScale = token_scale;
        if (token_scale === 'sizes' && !(config !== null && config !== void 0 && (_config$tokens$token_ = config.tokens[token_scale]) !== null && _config$tokens$token_ !== void 0 && _config$tokens$token_.hasOwnProperty(splitCurrentToken[0]))) {
          modifiedTokenScale = 'space';
        }
        if (!config || !config.tokens) {
          throw new Error('You cannot use tokens without wrapping the component with StyledProvider. Please wrap the component with a StyledProvider and pass theme config.');
        }
        if (deleteIfTokenNotExist) {
          if (!(config !== null && config !== void 0 && config.tokens[modifiedTokenScale])) {
            return '';
          }
        }
        if (config !== null && config !== void 0 && config.tokens[modifiedTokenScale] && config !== null && config !== void 0 && config.tokens[modifiedTokenScale].hasOwnProperty(splitCurrentToken[0])) {
          var _config$tokens;
          let tokenValue = config === null || config === void 0 || (_config$tokens = config.tokens) === null || _config$tokens === void 0 || (_config$tokens = _config$tokens[modifiedTokenScale]) === null || _config$tokens === void 0 ? void 0 : _config$tokens[splitCurrentToken[0]];
          typeofResult = typeof tokenValue;
          if (propsNotToConvertToCSSVariables.indexOf(propName) === -1 && !useResolvedValue && typeofResult !== 'undefined') {
            typeofResult = 'string';
            tokenValue = `var(--${modifiedTokenScale}-${convertToUnicodeString(splitCurrentToken[0])})`;
          }
          if (typeof tokenValue !== 'undefined' && tokenValue !== null) {
            return tokenValue;
          } else {
            return '';
          }
        }
      }
      if (deleteIfTokenNotExist) {
        return '';
      }
      return splitCurrentToken[splitCurrentToken.length - 1];
    }
  });
  let finalResult = result;
  // console.setEndTimeStamp('resolveStringToken');
  if (finalResult.length !== 0 && finalResult[0] === '') {
    return undefined;
  } else {
    finalResult = result.join(' ');
    if (isNumeric(finalResult) || typeofResult === 'number') {
      return parseFloat(finalResult);
    } else {
      return finalResult;
    }
  }
}
const getTokenFromConfig = (config, prop, value, useResolvedValue = false, deleteIfTokenNotExist = false) => {
  // console.setStartTimeStamp('getTokenFromConfig');

  const aliasTokenType = config.propertyTokenMap[prop];
  let IsNegativeToken = false;
  if (typeof value === 'string' && value.startsWith('-')) {
    IsNegativeToken = true;
    value = value.slice(1);
  }
  // const tokenScale = config?.tokens?.[aliasTokenType];
  let token;

  // resolveStringToken(value, config, config.propertyTokenMap);
  if (typeof value === 'string' && value.includes('$')) {
    var _config$propertyResol;
    if ((_config$propertyResol = config.propertyResolver) !== null && _config$propertyResol !== void 0 && _config$propertyResol[prop]) {
      var _config$propertyResol2;
      let transformer = (_config$propertyResol2 = config.propertyResolver) === null || _config$propertyResol2 === void 0 ? void 0 : _config$propertyResol2[prop];
      token = transformer(value, (value1, scale = aliasTokenType) => resolveStringToken(value1, config, config.propertyTokenMap, prop, scale, useResolvedValue, deleteIfTokenNotExist));
    } else {
      token = resolveStringToken(value, config, config.propertyTokenMap, prop, undefined, useResolvedValue, deleteIfTokenNotExist);
    }
  } else {
    var _config$propertyResol3;
    if ((_config$propertyResol3 = config.propertyResolver) !== null && _config$propertyResol3 !== void 0 && _config$propertyResol3[prop]) {
      var _config$propertyResol4;
      let transformer = (_config$propertyResol4 = config.propertyResolver) === null || _config$propertyResol4 === void 0 ? void 0 : _config$propertyResol4[prop];
      token = transformer(value, (value, scale = aliasTokenType) => {
        if (typeof value === 'string' && value.includes('$')) {
          return resolveStringToken(value, config, config.propertyTokenMap, prop, scale, useResolvedValue, deleteIfTokenNotExist);
        } else {
          return value;
        }
      });
    } else {
      token = value;
    }
  }
  if (IsNegativeToken) {
    if (typeof token === 'number') {
      token = -token;
    } else if (typeof token === 'string') {
      const negativeCSSVariableRegex = /^var\(.+\)$/;
      if (negativeCSSVariableRegex.test(token)) {
        token = `calc(${token} * -1)`;
      } else {
        token = `-${token}`;
      }
    }
  }

  // console.setEndTimeStamp('getTokenFromConfig');

  return token;
};
exports.getTokenFromConfig = getTokenFromConfig;
function getResolvedTokenValueFromConfig(config, _props, prop, value, useResolvedValue = false, deleteIfTokenNotExist = false) {
  let resolvedTokenValue = getTokenFromConfig(config, prop, value, useResolvedValue, deleteIfTokenNotExist);

  // Special case for token ends with em on mobile
  // This will work for lineHeight and letterSpacing
  // console.log('hello from token ends with em on mobile', resolvedTokenValue);
  // if (
  //   typeof resolvedTokenValue === 'string' &&
  //   resolvedTokenValue.endsWith('em') &&
  //   Platform.OS !== 'web'
  // ) {
  //   const fontSize = getTokenFromConfig(config, 'fontSize', props?.fontSize);
  //   resolvedTokenValue =
  //     parseFloat(resolvedTokenValue) * parseFloat(fontSize ?? BASE_FONT_SIZE);
  // }

  return resolvedTokenValue;
}
function resolveTokensFromConfig(config, props, useResolvedValue = false, deleteIfTokenNotExist = false) {
  let newProps = {};
  Object.keys(props).map(prop => {
    const value = props[prop];
    newProps[prop] = getResolvedTokenValueFromConfig(config, props, prop, value, useResolvedValue, deleteIfTokenNotExist);
  });
  return newProps;
}
function resolvedTokenization(props, config, ignoreKeys = new Set(), deleteIfTokenNotExist = false) {
  // console.setStartTimeStamp('resolvedTokenization');
  const aliasedResolvedProps = resolveAliasesFromConfig(config, props, ignoreKeys);
  const newProps = resolveTokensFromConfig(config, aliasedResolvedProps, false, deleteIfTokenNotExist);
  // console.setEndTimeStamp('resolvedTokenization');
  return newProps;
}
// ----------------------------------------------------- 6. Theme Boot Resolver -----------------------------------------------------
const deepMerge = (target = {}, source) => {
  // console.setStartTimeStamp('deepMerge');

  for (const key in source) {
    if (source.hasOwnProperty(key)) {
      if (typeof target[key] === 'object' && typeof source[key] === 'object') {
        deepMerge(target[key], source[key]);
      } else {
        target[key] = source[key];
      }
    }
  }
  // console.setEndTimeStamp('deepMerge');
  return target;
};
exports.deepMerge = deepMerge;
const shallowMerge = (target = {}, source) => {
  // console.setStartTimeStamp('deepMerge');
  return Object.assign(target, source);
};
exports.shallowMerge = shallowMerge;
function deepMergeObjects(...objects) {
  const isObject = obj => obj && typeof obj === 'object' && !Array.isArray(obj);
  return objects.reduce((prev, obj) => {
    if (isObject(prev) && isObject(obj)) {
      Object.keys(obj).forEach(key => {
        if (isObject(obj[key])) {
          if (!prev[key] || !isObject(prev[key])) {
            prev[key] = {};
          }
          prev[key] = deepMergeObjects(prev[key], obj[key]);
        } else {
          if (Array.isArray(obj[key]) && Array.isArray(prev[key])) {
            prev[key] = prev[key].concat(obj[key]); // Merge arrays without converting to an object
          } else {
            prev[key] = obj[key];
          }
        }
      });
    }
    return prev;
  }, {});
}
const deepMergeArray = (target = {}, source) => {
  for (const key in source) {
    if (source.hasOwnProperty(key)) {
      if (Array.isArray(target[key]) && Array.isArray(source[key])) {
        target[key] = [...target[key], ...source[key]];
      } else if (typeof target[key] === 'object' && typeof source[key] === 'object') {
        deepMergeArray(target[key], source[key]);
      } else {
        target[key] = source[key];
      }
    }
  }
  return target;
};
exports.deepMergeArray = deepMergeArray;
const BASE_FONT_SIZE = exports.BASE_FONT_SIZE = 16;
const convertAbsoluteToRem = px => {
  return `${px / BASE_FONT_SIZE}rem`;
};
exports.convertAbsoluteToRem = convertAbsoluteToRem;
const convertAbsoluteToPx = px => {
  return `${px}px`;
};
exports.convertAbsoluteToPx = convertAbsoluteToPx;
const convertRemToAbsolute = rem => {
  return rem * BASE_FONT_SIZE;
};
exports.convertRemToAbsolute = convertRemToAbsolute;
const platformSpecificSpaceUnits = (theme, platform) => {
  const scales = ['space', 'sizes', 'fontSizes', 'radii', 'borderWidths', 'lineHeights', 'letterSpacings'];
  let newTheme = {
    ...theme
  };
  const isWeb = platform === 'web';
  scales.forEach(key => {
    var _theme$tokens;
    // const scale = get(theme, key, {});
    //@ts-ignore
    const scale = (theme === null || theme === void 0 || (_theme$tokens = theme.tokens) === null || _theme$tokens === void 0 ? void 0 : _theme$tokens[key]) ?? {};
    const newScale = {
      ...scale
    };
    for (const scaleKey in scale) {
      const val = scale[scaleKey];
      if (typeof val !== 'object') {
        const isAbsolute = typeof val === 'number';
        const isPx = !isAbsolute && val.endsWith('px');
        const isRem = !isAbsolute && val.endsWith('rem');
        // const isEm = !isAbsolute && !isRem && val.endsWith('em');

        // console.log(isRem, key, val, isAbsolute, 'scale here');

        // If platform is web, we need to convert absolute unit to rem. e.g. 16 to 1rem
        if (isWeb) {
          // if (isAbsolute) {
          //   newScale[scaleKey] = convertAbsoluteToRem(val);
          // }
          if (isAbsolute) {
            newScale[scaleKey] = convertAbsoluteToPx(val);
          }
        }
        // If platform is not web, we need to convert px unit to absolute and rem unit to absolute. e.g. 16px to 16. 1rem to 16.
        else {
          if (isRem) {
            newScale[scaleKey] = convertRemToAbsolute(parseFloat(val));
          } else if (isPx) {
            newScale[scaleKey] = parseFloat(val);
          }
        }
      }
    }
    if (newTheme.tokens) {
      var _newTheme;
      newTheme = {
        ...newTheme,
        tokens: {
          ...((_newTheme = newTheme) === null || _newTheme === void 0 ? void 0 : _newTheme.tokens)
        }
      };
      //@ts-ignore
      newTheme.tokens[key] = newScale;
    }
    // else {
    //   console.warn(
    //     'No tokens found in config! Please pass config in Provider to resolve styles!'
    //   );
    // }
  });
  return newTheme;
};
exports.platformSpecificSpaceUnits = platformSpecificSpaceUnits;
function extractWidthValues(condition) {
  const widthRegex = /\((min-width|max-width)?\s*:\s*(\d+)\s*(px)?\)/g;
  const matches = [...condition.matchAll(widthRegex)];
  const widthValues = [];
  for (const match of matches) {
    if (match[1]) {
      widthValues.push(parseInt(match[2]));
    } else {
      widthValues.push(parseInt(match[2]));
    }
  }
  return widthValues;
}
function addThemeConditionInMeta(originalThemeObject, CONFIG) {
  let themeObject = originalThemeObject;
  themeObject.meta.themeCondition = {};
  // Creating theme conditions for theme
  Object.keys(themeObject.original).forEach(resolvedToken => {
    Object.keys(CONFIG.themes ?? {}).forEach(themeName => {
      let theme = CONFIG.themes[themeName];
      Object.keys(theme).forEach(tokenScale => {
        const tokenScaleValue = theme[tokenScale];
        Object.keys(tokenScaleValue).forEach(token => {
          if (!themeObject.meta.themeCondition[themeName]) {
            themeObject.meta.themeCondition[themeName] = {};
          }
          if (themeObject.original[resolvedToken] === token) {
            themeObject.meta.themeCondition[themeName] = {
              ...themeObject.meta.themeCondition[themeName],
              ...resolvedTokenization({
                [resolvedToken]: tokenScaleValue[token]
              }, CONFIG)
            };
          }
        });
      });
    });
  });
  return themeObject;
}
function resolvePlatformTheme(theme, platform) {
  if (typeof theme === 'object') {
    Object.keys(theme).forEach(themeKey => {
      if (themeKey !== 'style' && themeKey !== 'defaultProps') {
        if (theme[themeKey].platform) {
          let temp = {
            ...theme[themeKey]
          };
          theme[themeKey] = deepMerge(temp, theme[themeKey].platform[platform]);
          delete theme[themeKey].platform;
          resolvePlatformTheme(theme[themeKey], platform);
        } else if (themeKey === 'queries') {
          theme[themeKey].forEach(query => {
            if (query.value.platform) {
              let temp = {
                ...query.value
              };
              query.value = deepMerge(temp, query.value.platform[platform]);
              delete query.value.platform;
            }
            resolvePlatformTheme(query.value, platform);
          });
        } else {
          resolvePlatformTheme(theme[themeKey], platform);
        }
      }
    });
  }
}
//# sourceMappingURL=utils.js.map